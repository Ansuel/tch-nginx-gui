#!/bin/ash /etc/rc.common

#
#
#	 Custom Gui for Technicolor Modem: utility script and modified gui for the
#	 								   Technicolor Modem interface based on OpenWrt
#
#	Copyright (C) 2018  Christian Marangi <ansuelsmth@gmail.com>
#
#	This file is part of Custom Gui for Technicolor Modem.
#
#	Custom Gui for Technicolor Modem is free software: you can redistribute it and/or modify
#	it under the terms of the GNU General Public License as published by
#	the Free Software Foundation, either version 3 of the License, or
#	(at your option) any later version.
#
#	Custom Gui for Technicolor Modem is distributed in the hope that it will be useful,
#	but WITHOUT ANY WARRANTY; without even the implied warranty of
#	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#	GNU General Public License for more details.
#
#	You should have received a copy of the GNU General Public License
#	along with Custom Gui for Technicolor Modem.  If not, see <http://www.gnu.org/licenses/>.
#
#

START=94
EXTRA_COMMANDS="force debug"
EXTRA_HELP="\
        force   Force install GUI even if looks already installed
        debug   Force install GUI with also debug logs
"
#Gui version is now autocompleted base on latest dev, this variable will be replaced by the automatic script
version_gui=TO_AUTO_COMPLETE
#Latest version on TIM cwmp for version spoof
latest_version_on_TIM_cwmp="2.2.0"

logo_project() {
  cat <<EOF >/dev/console

 █████╗ ███╗   ██╗███████╗██╗   ██╗███████╗██╗
██╔══██╗████╗  ██║██╔════╝██║   ██║██╔════╝██║
███████║██╔██╗ ██║███████╗██║   ██║█████╗  ██║
██╔══██║██║╚██╗██║╚════██║██║   ██║██╔══╝  ██║
██║  ██║██║ ╚████║███████║╚██████╔╝███████╗███████╗
╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝ ╚═════╝ ╚══════╝╚══════╝
(Modified Gui RootScript)                  (Christo)

EOF

  logger <<EOF
                                    _
    /\  (Modified Gui RootScript)  | |
   /  \    _ __   ___  _   _   ___ | |
  / /\ \  | '_ \ / __|| | | | / _ \| |
 / ____ \ | | | |\__ \| |_| ||  __/| |
/_/    \_\|_| |_||___/ \__,_| \___||_|
                            (Christo)
EOF
}

####################LOG FUNCTION#################
logger_command() {
  if [ "$debug" -eq 1 ]; then
    logger -t "Root Script" "$1"
	  echo "Root Script" "$1"
  fi
}
#################################################

disable_upload_coredump_and_reboot() {
  #disable upload of coredump...
  #This is a modified build so let's not full server with false coredump.
  if [ "$(uci get -q system.@coredump[0].action)" != "ignore" ]; then
    uci set system.@coredump[0].action="ignore"
  fi
  if [ "$(uci get -q system.@coredump[0].reboot)" != "0" ]; then
    logger_command "Disable reboot after crash, this gives race condition..."
    uci set system.@coredump[0].reboot='0'
  fi
  #Clean coredump
  if [ "$(find /root -type f -name "*.core.*")" ]; then
    for coredump in /root/*.core.*; do
      logger_command "Removing coredump $coredump from /root..."
      rm "$coredump"
    done
  fi
}

enable_serial_console() {
	#Enable hardware serial console to intercept bootloops
	if grep -q '#::askconsolelate' /etc/inittab; then
    logger_command "Enabling hardware serial console..."
	  sed -i 's/#//' /etc/inittab
	fi
}

check_and_apply_root() {
  #modgui_old file is created before reboot for a firmware update, and store our root passwd
  [ -f /etc/modgui_old ] && mv /etc/modgui_old /etc/config/modgui

  encrypted_pass=$(awk -F: '/root/ {print $2 }' /etc/shadow)
  default_encrypted_pass='$5liEJpfo7NYE'
  saved_encrypted_pass=$(uci -q get modgui.var.encrypted_pass)

  store_pass_in_uci() {
    #Redefine encrypted_pass as this can change after the shadow check
    encrypted_pass=$(awk -F: '/root/ {print $2 }' /etc/shadow)
    echo "  New password detected!" >/dev/console
    echo "  Storing encrypted password..." >/dev/console
    if [ ! -f /etc/config/modgui ]; then
      touch /etc/config/modgui
      uci set modgui.var=var
    fi
    uci set modgui.var.encrypted_pass="$encrypted_pass"
    uci commit modgui
  }

  logger_command "Saving hashed root password in uci if modified..."

  #Enable root access to the real shell (default is /bin/restricted_shell)
  if [ "$(awk -F: '/root/ {print $7 }' /etc/passwd)" != "/bin/ash" ]; then
    logger_command "Enabling ash shell to root..."
    sed -i 's#/root:.*$#/root:/bin/ash#' /etc/passwd
  fi

  if [ -f /shadow_old ] && [ -f /root/.reapply_due_to_upgrade ]; then
    old_encrypted_pass=$(awk -F: '/root/ {print $2 }' /etc/shadow_old)
    sed -i -e 's|"${encrypted_pass}"|"${old_encrypted_pass}"|' /etc/shadow
    rm /shadow_old
    logger_command "Restoring old root password as this is a firmware upgrade!"
    echo "  Restoring old root password as this is a firmware upgrade!" >/dev/console
  elif [ -n "$saved_encrypted_pass" ]; then
    if [ "$encrypted_pass" != "$saved_encrypted_pass" ]; then
      if [ -f /root/.reapply_due_to_upgrade ]; then
        logger_command "Setting root password from password saved in config"
        echo "  Setting root password from password saved in config" >/dev/console
        sed -i -e 's|"${encrypted_pass}"|"${saved_encrypted_pass}"|' /etc/shadow
      else
        logger_command "Shadow contains different pass than saved one. Save it!"
        echo "  Shadow contains different pass than saved one. Save it!" >/dev/console
        store_pass_in_uci
      fi
    fi
  elif [ "$encrypted_pass" != "$default_encrypted_pass" ] || [ -f /root/.reapply_due_to_upgrade ]; then
    #Set the password to root so if needed the following sed know were to replace (default_encrypted_pass)
    echo -e "root\nroot" | passwd >/dev/null
    #Redefine encrypted_pass as this can change after the shadow check (if we restored an old shadow file)
    encrypted_pass=$(awk -F: '/root/ {print $2 }' /etc/shadow)
    if [ "$encrypted_pass" != "$default_encrypted_pass" ]; then
      sed -i -e 's|"${encrypted_pass}"|"${default_encrypted_pass}"|' /etc/shadow
    fi
    logger_command "Setting root password"
    echo "  Setting root password" >/dev/console
    store_pass_in_uci
  elif [ "$encrypted_pass" == "$default_encrypted_pass" ]; then
    logger_command "Default root password detected"
    echo "  Default root password detected" >/dev/console
  elif [ "$encrypted_pass" == "$saved_encrypted_pass" ]; then
    logger_command "Changed-and-ucisaved root password detected!"
    echo "  Changed-and-ucisaved root password detected!" >/dev/console
  fi

  if [ -z "$saved_encrypted_pass" ]; then
    store_pass_in_uci
  fi

  logger_command "Checking and force-enabling dropbear SSH Server for root on lan"
  disable_conflicting_dropbear() {
      [ "${enable}" != "0" ] \
      && { [ "${Interface}" = "lan" ] || [ "${Interface}" = "" ]; } \
      && { [ "${Port}" = "22" ] || [ "${Port}" = "" ]; } \
      && uci set dropbear.${1}.enable=0
  }
  config_load "dropbear"
  config_foreach disable_conflicting_dropbear dropbear

  dropbear_path="dropbear.afg"
  if [ ! "$(uci get -q $dropbear_path)" ]; then
    uci add dropbear dropbear
    uci rename "$dropbear_path"=afg
  fi

  uci set "$dropbear_path".Interface='lan'
  uci set "$dropbear_path".RootLogin='1'
  uci set "$dropbear_path".Port='22'
  uci set "$dropbear_path".RootPasswordAuth='on' #dropbear root related
  uci set "$dropbear_path".PasswordAuth='on'
  uci set "$dropbear_path".enable='1'

  if [ "$(uci changes)" ]; then
    logger_command "Restarting Dropbear SSH Server..."
    uci commit dropbear
    /etc/init.d/dropbear enable
    /etc/init.d/dropbear restart >/dev/null
  fi

  firewall_path=$(uci show firewall | grep -m 1 $(fw3 -q print | egrep 'iptables -t filter -A zone_lan_input -p tcp -m tcp --dport 22 -m comment --comment "!fw3: .+" -j DROP' | sed -n -e 's/^iptables.\+fw3: \(.\+\)".\+//p') 2>/dev/null | sed -n -e "s/\(.\+\).name='.\+'$//p" 2>/dev/null)
  if [ "$firewall_path" ]; then
    logger_command "Restarting firewall cleaned from SSH drop rule..."
    uci -q set "$firewall_path".target='ACCEPT'
    /etc/init.d/firewall reload 2>/dev/null
  fi
}

install_gui() {

  [[ -z "$log_progress" ]] && log_progress=0
  [[ -z "$restart_dnsmasq" ]] && restart_dnsmasq=0

  logger -s -t 'Root Script' "Installing in progress..."

  logger_command "Start rooting"
  if [ ! -f /root/.install_gui ]; then #this check if the placeholder exist
    touch /root/.install_gui #this is a placeholder to know if the install process ends correctly (removed by 99_postreq.sh)
  fi

  if [ -d /etc/modgui_scripts ]; then
    for file in /etc/modgui_scripts/*; do
      logger_command "Executing $file"
      . $file
    done
  fi

  #Remove reapply file as the root process after upgrade has finished.
  if [ -f /root/.reapply_due_to_upgrade ]; then
    rm /root/.reapply_due_to_upgrade
  fi

  logger_command "Process complete. tch-nginx-gui is now installed!"
  echo "  Process complete. tch-nginx-gui is now installed!" >/dev/console
}

is_dual_bank() {
  grep -c "\"bank_2\"" /proc/mtd >/dev/null
}

get_bank_mtd() {
  cat /proc/mtd  | grep \"$1\" | sed 's/:.*//'
}

check_and_apply_obp() {
  check_obp=$(uci get -q modgui.var.check_obp)
  bootedbank=$(cat /proc/banktable/booted)
  activebank=$(cat /proc/banktable/active)
  notbooted=$(cat /proc/banktable/notbooted)
  notbooted_modgui_configfile="/overlay/$notbooted/etc/config/modgui"

  if [[ "$bootedbank" != "$activebank" && "$bootedbank" == "bank_2" ]]; then

    passiveversion=$(cat /proc/banktable/passiveversion)
    if [ "$passiveversion" != "Unknown" ]; then
      logger_command "OBP check: looks like passive bank have a valid version: $passiveversion"
      echo "  OBP check: looks like passive bank have a valid version: $passiveversion" >/dev/console
    fi

    #WARNING this is not really SAFE if overlay get fullfilled and the TFTP recovery firmware flashed in bank_1 cannot boot with an empty overlay
    # Possible solutions:
    #Opt 1: place scripts in the bank_1 (recovery overlay) that will run on boot checking free space and do an mtd erase of the overlay on low space
    #Opt 2: we have a free bank_1 firmware space, use it as overlay
    [ -d "/overlay/bank_1" ] && rm -rf "/overlay/bank_1"

    logger_command "OBP sanity check succeeded."
    echo "  OBP sanity check succeeded." >/dev/console
  else
    #OBP not OK, check if was an user choice otherwise automatically apply (this should be the case called also on first install)

    if [ ! "$(uci -q get modgui.var.check_obp)" ]; then
      #we must initialize the check_obp var as is not found
      if [ -f "$notbooted_modgui_configfile" ]; then
        #if we are in a clean bank_2 overlay but in the notbooted bank overlay there was a modgui config file restore var from it
        get_config_notbooted=$(< "$notbooted_modgui_configfile" grep check_obp | awk '{print $3}' | sed "s/'//g")
        if [ -n "$get_config_notbooted" ] && [ ! "$(uci -q get modgui.var.check_obp)" ]; then
          uci set modgui.var.check_obp="$get_config_notbooted"
          uci commit modgui
        fi
      else
        #inizialize check_obp default value and only if cannot read the var from elsewhere (inactive bank config)
        uci set modgui.var.check_obp="1"
        uci commit modgui
      fi
    fi

    if [ "$(uci -q get modgui.var.check_obp)" == "0" ]; then
      logger_command "OBP sanity check FAILED but check_obp set to 0... Not acting"
      echo "  OBP sanity check FAILED but check_obp set to 0... Not acting" >/dev/console
    else
      logger_command "OBP sanity check FAILED start autoplanning..."
      echo "  OBP sanity check FAILED start autoplanning..." >/dev/console

      if [ "$bootedbank" == "bank_2" ]; then
        # Activate bank_1
        echo bank_1 > /proc/banktable/active
        # Erase firmware in bank_1
        mtd erase bank_1
      else
        logger_command "Cloning to bank_2 and checking checksum..."
        echo "  Cloning to bank_2 and checking checksum..." >/dev/console
        bank1_mtd="/dev/$(get_bank_mtd bank_1)"
        bank2_mtd="/dev/$(get_bank_mtd bank_2)"
        # clone bank_1 into bank_2
        mtd write "$bank1_mtd" "$bank2_mtd"
        md5_bank_1=$(md5sum "$bank1_mtd" | awk '{ print $1 }')
        md5_bank_2=$(md5sum "$bank2_mtd" | awk '{ print $1 }')
        if [ "$md5_bank_1" == "$md5_bank_2" ]; then
          logger_command "Cloning complete, moving overlay..."
          echo "  Cloning complete, moving overlay..." >/dev/console
          # Clean any existing overlay for bank_2 firmware
          rm -rf /overlay/bank_2
          # Make a temp copy of overlay for bank_1 firmware
          cp -rf /overlay/bank_1 /tmp/bank_overlay_backup
          # Free up overlay space by removing existing overlay for bank_1 firmware
          rm -rf /overlay/bank_1
          # Use the previously made temp copy as overlay for bank_2 firmware
          cp -rf /tmp/bank_overlay_backup /overlay/bank_2
          logger_command "Activating and erasing bank_1..."
          echo "  Activating and erasing bank_1...." >/dev/console
          echo bank_1 > /proc/banktable/active
          mtd erase bank_1
          # Reboot to first valid firmware
          reboot
          exit 0
        else
          logger_command "Failed cloning bank_1 to bank_2 stopping!"
          echo "  Failed cloning bank_1 to bank_2 stopping!" >/dev/console
          exit 1
        fi
      fi
    fi
  fi
}

check_full_overlay() {
  overlay_percent=$(df /overlay | sed -n 2p | awk {'{print $5}'} | sed 's|%||')
  overlay_mtdblock=$(df /overlay | sed -n 2p | awk {'{print $1}'})
  bootedbank=$(cat /proc/banktable/booted)
  #Reset if rootfs more than 97% full
  if [ "$overlay_percent" -gt 96 ]; then
    logger_command "DETECTED FULL ROOTFS... TRYING TO RESTORE..."
    echo "  DETECTED FULL ROOTFS... TRYING TO RESTORE..." >/dev/console
    for dir in /overlay/"$bootedbank"/*; do
      if [ ! "$dir" == "/overlay/$bootedbank/etc" ]; then
        logger_command "TRYING TO SAVE ROOT BY REMOVING EVERY DIR EXCEPT /etc"
        echo "  TRYING TO SAVE ROOT BY REMOVING EVERY DIR EXCEPT /etc" >/dev/console
        rm -rf "$dir"
      fi
    done
    #Verify if rm did actually remove the files/folders (using /root as check) if not ERASE...
    if [ -d "/overlay/$bootedbank/root" ]; then
      logger_command "CAN'T REMOVE FILES... INITIALISING FULL ROOTFS ERASE"
      echo "  CAN'T REMOVE FILES... INITIALISING FULL ROOTFS ERASE" >/dev/console
      logger_command "THIS WILL RESTORE THE MODEM TO FACTORY SETTINGS"
      echo "  THIS WILL RESTORE THE MODEM TO FACTORY SETTINGS" >/dev/console
      mtd erase -r "$overlay_mtdblock"
    fi
  fi
}

###########################################################################################
#						Init.d function												  #
###########################################################################################

force() {
  force=1
  boot
}

debug() {
  export debug=1
  force=1
  boot
}

boot() {
  ubus send fwupgrade '{"state":"upgrading"}'

  logo_project

  logger -s -t 'Root Script' "Checking installation prerequisites, if needed installation will continue after reboot..."

  check_full_overlay
  enable_serial_console
  check_and_apply_root
  disable_upload_coredump_and_reboot
  #TODO: find a way to avoid apply OBP on GUI update and postpone to the next boot
  is_dual_bank && check_and_apply_obp

  [ -z "$rooted" ] && rooted=0
  [ -z "$force" ] && force=0
  [ -z "$debug" ] && export debug=0

  if [ -f /root/.install_gui ]; then
    logger_command "Detected install GUI request! Installing..."
    echo "  detected install GUI request! Installing..." >/dev/console
    install_gui
  else
    if [ $force -eq 1 ]; then
      logger_command "Force flag detected! Reinstalling..."
      echo "  force flag detected! Reinstalling..." >/dev/console
      install_gui
    else
      logger_command "No force flag detected! Doing nothing."
      echo "  No force flag detected! Doing nothing." >/dev/console
    fi
  fi

  ubus send fwupgrade '{ "state": "done" }'
}
