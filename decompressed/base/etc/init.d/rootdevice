#!/bin/ash /etc/rc.common

#
#
#	 Custom Gui for Technicolor Modem: utility script and modified gui for the 
#	 								   Technicolor Modem interface based on OpenWrt
#
#	Copyright (C) 2018  Christian Marangi <ansuelsmth@gmail.com>
#
#	This file is part of Custom Gui for Technicolor Modem.
#
#	Custom Gui for Technicolor Modem is free software: you can redistribute it and/or modify
#	it under the terms of the GNU General Public License as published by
#	the Free Software Foundation, either version 3 of the License, or
#	(at your option) any later version.
#
#	Custom Gui for Technicolor Modem is distributed in the hope that it will be useful,
#	but WITHOUT ANY WARRANTY; without even the implied warranty of
#	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#	GNU General Public License for more details.
#
#	You should have received a copy of the GNU General Public License
#	along with Custom Gui for Technicolor Modem.  If not, see <http://www.gnu.org/licenses/>.
#
#

START=94
EXTRA_COMMANDS="force debug"
EXTRA_HELP="\
		force   Force root process even when root flag is already set
		debug   force command with debug log
		install	This root the device for the initial installation
"
#Gui version is now autocompleted base on latest dev, this variable will be replaced by the automatic script
version_gui=TO_AUTO_COMPLETE
#Latest version on TIM cwmp for version spoof
latest_version_on_TIM_cwmp="2.0.0"

logo_project() {
cat << EOF > /dev/console

 █████╗ ███╗   ██╗███████╗██╗   ██╗███████╗██╗	 
██╔══██╗████╗  ██║██╔════╝██║   ██║██╔════╝██║	 
███████║██╔██╗ ██║███████╗██║   ██║█████╗  ██║	 
██╔══██║██║╚██╗██║╚════██║██║   ██║██╔══╝  ██║	 
██║  ██║██║ ╚████║███████║╚██████╔╝███████╗███████╗
╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝ ╚═════╝ ╚══════╝╚══════╝
(Modified Gui RootScript)				  (Christo)

EOF

logger << EOF

									 _ 
	 /\  (Modified Gui RootScript)  | |
	/  \	_ __   ___  _   _   ___ | |
   / /\ \  | '_ \ / __|| | | | / _ \| |
  / ____ \ | | | |\__ \| |_| ||  __/| |
 /_/	\_\|_| |_||___/ \__,_| \___||_|
									   
							 (Christo) 
EOF
}

check_root() {

	config_load "system"

	config_get_bool rooted config rooted 0

cat << EOF > /dev/console
 === IMPORTANT =======================================
  Checking root...
EOF
}


############TRANSFORMER UTILITY##################
set_transformer() {
	cmd="require('datamodel').set('$1','$2')"
	lua -e "$cmd"
}

get_transformer() {
	cmd="require('datamodel').get('$1')"
	lua -e "$cmd"
}
#################################################

log_progress=0
restart_dnsmasq=0

####################LOG FUNCTION#################
logger_command() {
	if [ "$debug"  -eq 1 ]; then
		logger -s -t "Root Script" "$1"
	fi
	if [ -z "$2" ]; then
	log_progress=$((log_progress+1))
		set_transformer "rpc.system.modgui.upgradegui.log_prog" $log_progress
		set_transformer "rpc.system.modgui.upgradegui.log" "$1"
	fi
}
#################################################
convert_gui_to_light_gz() {
	mkdir /tmp/extractemp
	bzcat /tmp/$1.tar.bz2 | tar -C /tmp/extractemp -xf -
	rm -r /tmp/extractemp/tmp
	cd  /tmp/extractemp/
	tar -zcf ../$1.tar.gz *
	cd ../../
	md5sum /tmp/$1.tar.bz2 | awk '{ print $1}' > /root/md5.gui_orig
	mv /tmp/$1.tar.gz /root/
	rm -r /tmp/extractemp
	rm /tmp/$1.tar.bz2
}
#################################################

add_ipoe() {
	uci set network.ipoe=interface
	uci set network.ipoe.proto='dhcp'
	uci set network.ipoe.metric='1'
	uci set network.ipoe.reqopts='1 3 6 43 51 58 59'
	uci set network.ipoe.release='1'
	uci set network.ipoe.neighreachabletime='1200000'
	uci set network.ipoe.neighgcstaletime='2400'
	uci set network.ipoe.ipv6='1'
}

remove_default_dns() {
	uci -q del network.loopback.dns
	uci -q del network.loopback.dns_metric
}

setup_network() {
	#Set a pppoerelay empty interface if list is not present (UNO)
	if [ ! "$(uci -q get network.lan.pppoerelay)" ]; then
		uci -q add_list network.lan.pppoerelay=''
	fi
	sed -i -e 's/option pppoerelay/list pppoerelay/g' /etc/config/network

	#Set a waneth4 interface if not found (fix wizard on UNO)
	if [ ! "$(uci -q get network.waneth4)" ]; then
		uci -q add network device > /dev/null
		uci -q rename network.@device[-1]=waneth4
		uci -q set network.waneth4.enabled=1
		uci -q set network.waneth4.type=8021q
		uci -q set network.waneth4.name=waneth4
		uci -q set network.waneth4.vid=835
	fi
	if [ ! "$(uci -q get network.waneth4.vid)" ]; then
		uci -q set network.waneth4.vid=835
	fi

	#Set a wanptm0 interface if not found (fix wizard on UNO)
	if [ ! "$(uci -q get network.wanptm0)" ]; then
		uci -q add network device > /dev/null
		uci -q rename network.@device[-1]=wanptm0
		uci -q set network.wanptm0.enabled=1
		uci -q set network.wanptm0.type=8021q
		uci -q set network.wanptm0.name=wanptm0
		uci -q set network.wanptm0.vid=835
	fi
	if [ ! "$(uci -q get network.wanptm0.vid)" ]; then
		uci -q set network.wanptm0.vid=835
	fi

	#Set a SSH_wan firewall rule if not found (fix SSH Wan not working)
	if [ ! "$(uci -q get firewall.SSH_wan)" ]; then
		uci -q add firewall rule > /dev/null
		uci -q rename firewall.@rule[-1]=SSH_wan
		uci -q set firewall.SSH_wan.src=wan
		uci -q set firewall.SSH_wan.name=SSH_wan
		uci -q set firewall.SSH_wan.target=DROP
		uci -q set firewall.SSH_wan.proto=tcp
		uci -q set firewall.SSH_wan.dest_port=22
		uci -q set firewall.SSH_wan.family=ipv4
	fi

	#Rename ppp interface to wan to fix problem with TG800 strange Telstra configuration
	if [ ! "$(uci -q get network.wan.proto)" ] && [ "$(uci -q get network.ppp)" ]; then
		uci del network.wan
		uci rename network.ppp=wan
	fi
}

check_variant_friendly_name() {
	#Get variant friendly name and save
	if [ ! "$(uci get -q env.var.variant_friendly_name)" ]; then
		variant=$(uci get env.var.prod_friendly_name)
		case "$variant"
		in
			DGA4130)
				variant=AGTEF ;;
			DGA4132)
				variant=AGTHP ;;
			Technicolor*)
				variant=${variant#Technicolor } ;;
			MediaAccess*)
				variant=${variant#MediaAccess } ;;
		esac
		uci set env.var.variant_friendly_name="$variant"
	fi
}

add_TIM_ppp_specific() {
	uci set modgui.var.ppp_mgmt="$(uci -q get env.var.serial)-$(uci -q get env.var.oui)@00000.aliceres.mgmt"
	uci set modgui.var.ppp_realm_ipv6="$(uci -q get env.var.serial)-$(uci -q get env.var.oui)@alice6.it"
}

puryfy_wan_interface() { #creano problemi di dns per chissa'  quale diavolo di motivo... Ma l'utilitÃ  di sta roba eh telecom ? 
	uci -q del network.wan.keepalive
	uci -q del network.wan.graceful_restart
	uci -q del network.wan_ipv6.keepalive
	uci -q del network.wan_ipv6.graceful_restart
}

fix_dns_dhcp_bug() {
	#SET odhcpd MAINDHCP to 0 to use dnsmasq for ipv4 
	if [ "$(uci get -q dhcp.odhcpd.maindhcp)" == "1" ]; then
		uci set dhcp.odhcpd.maindhcp="0"
		/etc/init.d/odhcpd restart
		restart_dnsmasq=1
	fi
	#Check to see if odhcpd is running
	if [ ! "$(pgrep "odhcpd")" ]; then
		/etc/init.d/odhcpd start
	fi
	#reenable it to make ipv6 works
	if [ ! "$(echo /etc/rc.d/*odhcpd*)" ]; then
		/etc/init.d/odhcpd enable
	fi
}

purify_from_tim() {
	uci -q del modgui.var.ppp_mgmt
	uci -q del network.wan_ipv6
	uci -q del dhcp.dnsmasq.server
	restart_dnsmasq=1
}

cumulative_check_gui() {
	#This create update_branch entities
	if [ ! "$(uci get -q modgui.gui.update_branch)" ]; then
		uci set modgui.gui.update_branch="stable"
		update_branch=""
		logger_command "Setting update branch to STABLE"
	elif [ "$(uci get -q modgui.gui.update_branch)" == "stable" ]; then
		update_branch=""
		logger_command "Update branch detected: STABLE"
	else
		update_branch="_dev"
		logger_command "Update branch detected: DEV"
	fi


	#This makes sure we have stable GUI in /root
	if [ ! -f /root/GUI.tar.bz2 ] && [ ! -f /root/GUI.tar.gz ]; then
		logger_command "Stable GUI not found in /root"
		if [ ! -f /tmp/GUI.tar.bz2 ]; then
			logger_command "Stable GUI not found in /tmp..."
			logger_command "Checking if GUI_dev is present in /tmp"
			if [ -f /tmp/GUI_dev.tar.bz2 ]; then
				logger_command "Found GUI_dev in /tmp, copying to stable to generate a valid hash"
				cp /tmp/GUI_dev.tar.bz2 /root/GUI.tar.bz2
			elif ping -q -c 1 -W 1 8.8.8.8 >/dev/null 2>&1; then
				logger_command "Downloading stable..."
				curl -k -s https://repository.ilpuntotecnico.com//files/Ansuel/AGTEF/GUI.tar.bz2 --output /root/GUI.tar.bz2
			else
				logger_command "Can't download stable GUI!"
			fi
		else
			logger_command "Moving stable GUI from /tmp to /root"
			cp /tmp/GUI.tar.bz2 /root
		fi
		if [ -f /root/GUI.tar.bz2 ] && [ -s /root/GUI.tar.bz2 ]; then
			logger_command "Assuming first time install, cleaning /www dir and reinstalling"
			rm -r /www/*
			bzcat /root/GUI.tar.bz2 | tar -C / -xf - www
		fi
	fi

	if [ -f /tmp/GUI$update_branch.tar.bz2 ]; then
		overlay_space=$(df /overlay | sed -n 2p | awk {'{print $2}'})
		if [ "$overlay_space" -lt 33000 ]; then
			convert_gui_to_light_gz "GUI"$update_branch
		else
			logger_command "Updating GUI in /root folder from /tmp"
			#This move the gui found in tmp to /root
			
			if [ -f /root/GUI$update_branch.tar.bz2 ]; then
				rm /root/GUI$update_branch.tar.bz2
			fi
			mv /tmp/GUI$update_branch.tar.bz2 /root/GUI$update_branch.tar.bz2
		fi
	fi

	#This generates new hash
	if [ -f /root/GUI$update_branch.tar.bz2 ] || [ -f /root/GUI.tar.gz ]; then
		old_gui_hash=$(uci get -q modgui.gui.gui_hash)
		if [ -f /root/GUI.tar.gz ]; then
			gui_hash=$(cat /root/md5.gui_orig)
		else
			gui_hash=$(md5sum /root/GUI$update_branch.tar.bz2 | awk '{ print $1}' )
		fi
		if [ "$old_gui_hash" != "$gui_hash" ]; then
			logger_command "Detected upgrade!"
			logger_command "Old GUI hash: $old_gui_hash"
			logger_command "New GUI hash: $gui_hash"
		else
			logger_command "GUI hash set: $old_gui_hash"
		fi
	else
		logger_command "Can't generate GUI hash, file not found!"
		gui_hash="0"
	fi

	logger_command "Resetting version info..."

	if [ ! "$(uci get -q modgui.gui.gui_hash)" ]; then
		uci set modgui.gui.new_ver="Unknown"
		uci set modgui.gui.gui_hash=$gui_hash
		uci set modgui.gui.outdated_ver='0'
	elif [ "$(uci get -q modgui.gui.gui_hash)" != $gui_hash ]; then
		uci set modgui.gui.new_ver="Unknown"
		uci set modgui.gui.gui_hash=$gui_hash
		uci set modgui.gui.outdated_ver='0'
	fi
	if [ ! "$(uci get -q modgui.gui.autoupgrade)" ]; then
		uci set modgui.gui.autoupgrade_hour=0
		uci set modgui.gui.autoupgrade=0
	fi
	if [ ! "$(uci get -q modgui.gui.autoupgradeview)" ]; then
		uci set modgui.gui.autoupgradeview="none"
	fi
	if [ ! "$(uci get -q modgui.gui.firstpage)" ]; then
		uci set modgui.gui.firstpage="stats"
	fi
	if [ ! "$(uci get -q modgui.gui.randomcolor)" ]; then
		uci set modgui.gui.randomcolor="0"
	fi
}

transfer_bank() {
	#This function will clone and switch banks
	if [ -d /overlay/bank_1 ]; then
		rm -r /overlay/bank_1
	fi
	mkdir /overlay/bank_1
	cp -a /overlay/bank_2/* /overlay/bank_1/
	if [ -f /overlay/bank_1/etc/init.d/rootdevice ]; then
		#mtd erase /dev/mtd3
		mtd write /dev/mtd4 /dev/mtd3
	fi
	activeversion=$( cat /proc/banktable/activeversion )
	passiveversion=$( cat /proc/banktable/passiveversion )

	if [ "$activeversion" == "$passiveversion" ]; then
		echo bank_1 > /proc/banktable/active
		reboot
	fi
}

restore_bank() {
	#This function will clone bank1 to bank2 or vice-versa
	bootedbank=$( cat /proc/banktable/booted )
	activebank=$( cat /proc/banktable/active )
	if [ -f "/overlay/$activebank" ]; then
		rm -r "/overlay/$activebank"
	fi
	mkdir "/overlay/$activebank"
	cp -a "/overlay/$bootedbank/*" "/overlay/$activebank"
	if [ -f "/overlay/$activebank/etc/init.d/rootdevice" ]; then
		if [ "$bootedbank" == "bank_1" ]; then
			mtd write /dev/mtd3 /dev/mtd4
		else
			mtd write /dev/mtd4 /dev/mtd3
		fi
	fi

	if [ "$activeversion" == "$passiveversion" ]; then
		echo "$bootedbank" > /proc/banktable/active
		reboot
	fi
}

check_gui_ver() {
	if [ "$(uci -q get modgui.gui.gui_version)" != $version_gui ]; then
		uci set modgui.gui.gui_version=$version_gui
	fi
}

check_new_dlnad() {
	#This function will check to see which dlna server daemon is installed
	if [ -f /etc/init.d/dland ] && [ ! -k /etc/rc.d/S98dlnad ] && [ -f /etc/init.d/minidlna ]; then
		if [ "$(pgrep "minidlna")" ] ; then
			/etc/init.d/minidlna stop
		fi
		/etc/init.d/minidlna disable
		/etc/init.d/dlnad enable
		if [ ! "$(pgrep "dlnad")" ] ; then
			/etc/init.d/dlnad start
		fi
	fi
	if [ -f /rom/usr/bin/dlnad ]; then
		if [ "$(md5sum /rom/usr/bin/dlnad | awk '{print $1}')" !=  "$(md5sum /usr/bin/dlnad | awk '{print $1}')" ]; then
			if [ "$(pgrep "dlnad")" ] ; then
				/etc/init.d/dlnad stop
			fi
			rm /usr/bin/dlnad
			cp /rom/usr/bin/dlnad /usr/bin/dlnad
			cp /rom/etc/init.d/dlnad /etc/init.d/dlnad
			/etc/init.d/dlnad start
		fi
	fi
}

check_upgrade_shit() {
	if [ -f /lib/upgrade/resetgui.sh ]; then
		rm /lib/upgrade/resetgui.sh
		rm /lib/upgrade/transfer_bank1.sh
		rm /lib/upgrade/upgradegui.sh 
		rm /lib/upgrade/checkver.sh 
		rm /lib/upgrade/hardreset.sh
	fi
}

check_isp_config() {
	#Detect ISP based on cwmp settings (Italian only)
	ppp_user=$(uci -q get network.wan.username)
	cwmp_url=$(uci -q get cwmpd.cwmpd_config.acs_url)
	if  [ ! "$ppp_user" ]; then
		uci set modgui.var.isp="Other"
		purify_from_tim
	else
		if echo "$ppp_user" | grep -q "alice" || 
		   echo "$ppp_user" | grep -q "agcombo" || 
		   echo "$ppp_user" | grep -q "unica" || 
		   echo "$ppp_user" | grep -q "aliceres" ||
		   echo "$ppp_user" | grep -q "@00000." ; 
		then
			uci set modgui.var.isp="TIM"
		elif echo "$ppp_user" | grep -q "tiscali.it" || #acs tiscali is preconfigured 
			echo "$cwmp_url" | grep -q "tiscali.it" ; then #on tiscali firmware only
			uci set modgui.var.isp="Tiscali"
		elif echo "$cwmp_url" | grep -q "59.0.121.191" ; then #on fastweb firmware only
			uci set modgui.var.isp="Fastweb"
		else
			uci set modgui.var.isp="Other"
			purify_from_tim
		fi
	fi
}

create_symlink() {
	#Links the pached binaries to their correct paths
	if [ -f /bin/busybox_telnet ]; then
		ln -sf ../../bin/busybox_telnet /usr/sbin/telnetd
		/etc/init.d/telnet enable
	fi
	if [ ! -f /etc/rc.d/S70wol ]; then 
		/etc/init.d/wol enable
	fi
}

orig_config_gen() {
	if [ ! -f /etc/config/wol ] && [ -f /etc/config/wol_orig ]; then
		mv /etc/config/wol_orig /etc/config/wol
	else
		if [ -f /etc/config/wol_orig ]; then
			rm /etc/config/wol_orig
		fi
	fi
	if [ ! -f /etc/config/dlnad ] && [ -f /etc/config/dlnad_orig ]; then
		mv /etc/config/dlnad_orig /etc/config/dlnad
	else
		if [ -f /etc/config/dlnad_orig ]; then
			rm /etc/config/dlnad_orig
		fi
	fi
	if [ ! -f /etc/config/telnet ] && [ -f /etc/config/telnet_orig ]; then
		mv /etc/config/telnet_orig /etc/config/telnet
	else
		if [ -f /etc/config/telnet_orig ]; then
			rm /etc/config/telnet_orig
		fi
	fi
}

trafficmon_support() {
	if [ -d /root/trafficmon ]; then
		killall trafficmon
		rm -rf /root/trafficmon
	fi
	if [ -f /etc/init.d/trafficmon ] && [ ! -k /etc/rc.d/S99trafficmon ] && [ ! -d /tmp/trafficmon ]; then
		/etc/init.d/trafficmon enable
		if [ ! "$(pgrep "trafficmon.lua")" ]; then
			/etc/init.d/trafficmon start
		fi
	fi

}

checkver_cron() {
	if [ -f /etc/crontabs/root ]; then #remove from cron old checkver.sh script
		sed -i '/checkver.sh/d' /etc/crontabs/root
		if [ $(ls -l /etc/crontabs/root | awk '{print $3}') != "root" ]; then
			rm /etc/crontabs/root #THIS CHECK A VALID ROOT CRON... we remove it as it's useless if the owner is not root.
		fi
	fi
	if [ ! -f /etc/crontabs/root ] || [ ! "$(< /etc/crontabs/root grep checkver)" ]; then
		rand_h=$(awk -v min=1 -v max=6 'BEGIN{srand(); print int(min+rand()*(max-min+1))}')
		rand_m=$(awk -v min=1 -v max=59 'BEGIN{srand(); print int(min+rand()*(max-min+1))}')
		echo "$rand_m $rand_h * * * /usr/share/transformer/scripts/checkver >/dev/null 2>&1" >> /etc/crontabs/root
		/etc/init.d/cron restart
	fi
}

restore_original_mapper() {
	local orig_dir=/rom/usr/share/transformer/mappings
	local target=/usr/share/transformer/mappings

	if [ "$(md5sum $orig_dir/device2/Device.map | awk '{print $1}')" != "$(md5sum $target/device2/Device.map | awk '{print $1}')" ]; then
		mkdir /tmp/tmp_bff_file
		cp $target/bbf/VoiceService* /tmp/tmp_bff_file/
		rm -r $target/bbf/*
		rm -r $target/device2/*
		rm -r $target/clash/*
		rm -r $target/igd/*
		cp $orig_dir/bbf/* $target/bbf
		cp $orig_dir/clash/* $target/clash
		cp $orig_dir/device2/* $target/device2
		cp $orig_dir/igd/* $target/igd
		cp /tmp/tmp_bff_file/* $target/bbf
		rm -r /tmp/tmp_bff_file
		logger_command "Restoring mapper device file"
	fi
	if [ ! -f $target/bbf/VoiceService.VoiceProfile.Line.map ]; then
		cp $orig_dir/bbf/VoiceService.VoiceProfile.Line.map $orig_dir/bbf/
	elif [ "$(md5sum $orig_dir/bbf/VoiceService.VoiceProfile.Line.map | awk '{print $1}')" != "$(md5sum $target/bbf/VoiceService.VoiceProfile.Line.map | awk '{print $1}')" ]; then
		rm "$target/bbf/VoiceService.VoiceProfile.Line.map"
		cp "$orig_dir/bbf/VoiceService.VoiceProfile.Line.map" "$orig_dir/bbf/"
	fi #Solve some problems with cwmp AGTEF_1.0.3

	#Remove ignored Root device naming from transformer
	uci del_list transformer.@main[0].ignore_patterns='^Device%.'
	uci del_list transformer.@main[0].ignore_patterns='^InternetGatewayDevice%.'
}

transformer_lib_check() {
	local orig_dir=/rom/usr
	local target=/usr

	if [ "$(md5sum $orig_dir/lib/lua/transformer/commitapply.lua | awk '{print $1}')" != "$(md5sum $target/lib/lua/transformer/commitapply.lua | awk '{print $1}')" ]; then
		rm $target/share/transformer/mappings/rpc/*
		rm $target/share/transformer/mappings/uci/*
		rm -r $target/lib/lua/tch/*
		rm -r $target/lib/lua/transformer/*
		cp $orig_dir/share/transformer/mappings/rpc/* $target/share/transformer/mappings/rpc
		cp $orig_dir/share/transformer/mappings/uci/* $target/share/transformer/mappings/uci
		cp $orig_dir/bin/transformer $target/bin/
		cp -r $orig_dir/lib/lua/tch/* $target/lib/lua/tch
		cp -r $orig_dir/lib/lua/transformer/* $target/lib/lua/transformer
		gui_pos=""
		if [ -f /root/GUI.tar.bz2 ]; then
			gui_pos=/root/GUI.tar.bz2
		elif [ -f /root/GUI_dev.tar.bz2 ]; then
			gui_pos=/root/GUI_dev.tar.bz2
		elif [ -f /tmp/GUI.tar.bz2 ]; then
			gui_pos=/tmp/GUI.tar.bz2
		elif [ -f /tmp/GUI_dev.tar.bz2 ]; then
			gui_pos=/tmp/GUI_dev.tar.bz2
		fi
		logger_command "Found gui here: "$gui_pos
		if [ $gui_pos != "" ] && [ -s $gui_pos ]; then
			bzcat $gui_pos | tar -C / -xf - usr #reapply the upgrade as in the gui we store some of this file that we restored
			logger_command "Restoring transformer lib" #What is going on here? Doesn't even restart transformer???
		fi
		#/etc/init.d/transformer restart
	fi
}

check_uci_gui_skin() {
	if [ ! "$(uci get -q modgui.gui.gui_skin)" ]; then
		uci set modgui.gui.gui_skin="green"
	fi
}

remove_https_check_cwmpd() {
	uci set cwmpd.cwmpd_config.enforce_https='0'
	uci set cwmpd.cwmpd_config.ssl_verifypeer='0'
}

add_telecom_stock_dns() {
	if [ ! "$(uci get -q dhcp.dnsmasq.server)" ]; then
		uci set dhcp.dnsmasq.server='151.99.125.1'
		restart_dnsmasq=1
	fi
}

check_dnsmasq_name() {
	#Checks what the dnsmasq daemon is referred to in the config file
	if [ "$(uci get -q dhcp.dnsmasq)" ]; then
		if [ "$(uci get -q dhcp.dnsmasq)" != "dnsmasq" ]; then
			uci set dhcp.dnsmasq=dnsmasq
			restart_dnsmasq=1
		fi
	else
		uci set dhcp.dnsmasq=dnsmasq
		restart_dnsmasq=1
	fi
	if uci show dhcp | grep -q "dhcp.@dnsmasq" ; then
		uci rename dhcp.@dnsmasq[0]=dnsmasq
		restart_dnsmasq=1
	fi
}

create_driver_setting() {
	#Get xdsl driver(s) version and save to GUI config file
	if [ ! "$(uci get -q modgui.var.driver_version)" ]; then
		uci set modgui.var.driver_version="$(xdslctl --version 2>&1 >/dev/null | grep 'version -' | awk '{print $6}' | sed 's/\..*//')"
	else 
		if [ "$(uci get -q modgui.var.driver_version | grep -F .)" ]; then
			uci set modgui.var.driver_version="$(xdslctl --version 2>&1 >/dev/null | grep 'version -' | awk '{print $6}' | sed 's/\..*//')"
		fi
	fi
}

dropbear_file_check() {
	#Check to see if the dropbear_new config file is present in /etc/config, if so then move it to /etc/config/dropbear
	if [ -f /etc/config/dropbear_new ]; then
		if [ "$(uci get -q dropbear.wan.enable)" ]; then
			rm /etc/config/dropbear_new
		else
			rm /etc/config/dropbear
			mv /etc/config/dropbear_new /etc/config/dropbear
		fi
	fi
}

check_noip_file() {
	#Check to see if DDNS scripts config is present
	if [ -d /etc/ddns_new ]; then
		if [ -d /etc/ddns ]; then
				rm -r /etc/ddns_new
		else
			mv /etc/ddns_new /etc/ddns
		fi
	fi
}

eco_param() {
	#Set CPU to full power (full clock)
	if [ ! "$(uci get -q power.cpu)" ]; then
		uci set power.cpu=cpu
		uci set power.cpu.cpuspeed='256'
		uci set power.cpu.wait='1'
		logger_command "Restarting power management"
		/etc/init.d/power restart
	fi
}

enable_new_upnp() {
	if [ -f /etc/init.d/miniupnpd ]; then
		if [ "$(uci get -q upnpd.config.enable_upnp)" ]; then
			if [ "$(uci get -q upnpd.config.enable_upnp)" == "1" ]; then
				/etc/init.d/miniupnpd-tch stop
				/etc/init.d/miniupnpd-tch disable
				/etc/init.d/miniupnpd enable
				if [ ! "$(pgrep "miniupnpd")" ]; then
					/etc/init.d/miniupnpd restart
				fi
			fi
		fi
	fi
}

wifi_fix_24g() {
	#Set wifi to perf mode
	wl down
	wl obss_prot set 0
	wl -i wl0 gmode Performance
	wl -i wl0 up

}

create_gui_type() {
	#Gathers various infomation about what programs are installed and saves it in the modgui config file
	if [ ! "$( uci get -q modgui.app.aria2_webui)" ]; then
		if [ -d /www/docroot/aria ]; then
			uci set modgui.app.aria2_webui="1"
		else
			uci set modgui.app.aria2_webui="0"
		fi
	elif [ "$( uci get -q modgui.app.aria2_webui)" == "1" ] &&
	[ ! -d /www/docroot/aria ] && 
	[ -f /usr/share/transformer/scripts/install_aria2.sh ]; then 
		#this restore aria... my bad for this bug...
		/usr/share/transformer/scripts/install_aria2.sh
	fi
	if [ ! "$( uci get -q modgui.app.luci_webui)" ]; then
		if [ -d /www_luci ]; then
			uci set modgui.app.luci_webui="1"
		else
			uci set modgui.app.luci_webui="0"
		fi
	fi
	if [ ! "$( uci get -q modgui.app.amule_webui)" ]; then
		if [ -d /www/docroot/amule ]; then
			uci set modgui.app.amule_webui="1"
		else
			uci set modgui.app.amule_webui="0"
		fi
	fi
	if [ ! "$( uci get -q modgui.app.transmission_webui)" ]; then
		if [ -d /www/docroot/transmission ]; then
			uci set modgui.app.transmission_webui="1"
		else
			uci set modgui.app.transmission_webui="0"
		fi
	fi
	if [ ! "$( uci get -q modgui.app.xupnp_app)" ]; then
		if [ -d /usr/share/xupnpd ]; then
			uci set modgui.app.xupnp_app="1"
		else
			uci set modgui.app.xupnp_app="0"
		fi
	fi
	if [ ! "$( uci get -q modgui.app.blacklist_app)" ]; then
		if [ -d /etc/asterisk ]; then
			uci set modgui.app.blacklist_app="1"
		else
			uci set modgui.app.blacklist_app="0"
		fi
	elif [ "$( uci get -q modgui.app.blacklist_app)" == "1" ] &&
	[ ! -f /www/docroot/modals/mmpbx-contacts-modal.lp.orig ] &&
	[ -f /usr/share/transformer/scripts/install_blacklist.sh ]; then
		/usr/share/transformer/scripts/install_blacklist.sh
	fi
}

update_dhcp_config() {
	if [ "$(uci get -q dhcp.lan.dhcpv4)" ]; then
		#REMOVE DHCPV4 this is for odhcpd daemon to tell him to run also for ipv4 dhcp...
		#by removing the entities we solve the problem
		uci del dhcp.lan.dhcpv4
	fi
	if [ ! "$(uci get -q dhcp.lan.ignore)" ]; then
		uci set dhcp.lan.ignore='0'
	fi
}

add_new_web_rule() {
	#Adds all of the needed UCI rules to enable the web interface into /etc/config/web
	if [ ! "$(uci get -q web.applicationsmodal)" ]; then
		uci set web.applicationsmodal=rule
		uci set web.applicationsmodal.target='/modals/applications-modal.lp'
		uci add_list web.applicationsmodal.roles='admin' 
		uci add_list web.applicationsmodal.roles='engineer'
		uci add_list web.ruleset_main.rules='applicationsmodal'
	fi
	if [ ! "$(uci get -q web.ajaxgatewaytab)" ]; then
		uci set web.ajaxgatewaytab=rule
		uci set web.ajaxgatewaytab.target='/ajax/cpuload.lua'
		uci add_list web.ajaxgatewaytab.roles='admin' 
		uci add_list web.ajaxgatewaytab.roles='engineer'
		uci add_list web.ajaxgatewaytab.roles='guest'
		uci add_list web.ruleset_main.rules='ajaxgatewaytab'
	fi
	if [ ! "$(uci get -q web.ajaxinternet)" ]; then
		uci set web.ajaxinternet=rule
		uci set web.ajaxinternet.target='/ajax/internet.lua'
		uci add_list web.ajaxinternet.roles='admin' 
		uci add_list web.ajaxinternet.roles='engineer'
		uci add_list web.ajaxinternet.roles='guest'
		uci add_list web.ruleset_main.rules='ajaxinternet'
	fi
	if [ ! "$(uci get -q web.diagnosticsxdslgraphicsmodal)" ]; then
		uci set web.diagnosticsxdslgraphicsmodal=rule
		uci set web.diagnosticsxdslgraphicsmodal.target='/modals/diagnostics-xdsl-graphics-modal.lp'
		uci add_list web.diagnosticsxdslgraphicsmodal.roles='admin' 
		uci add_list web.diagnosticsxdslgraphicsmodal.roles='engineer'
		uci add_list web.diagnosticsxdslgraphicsmodal.roles='guest'
		uci add_list web.ruleset_main.rules='diagnosticsxdslgraphicsmodal'
	fi
	if [ ! "$(uci get -q web.mwanmodal)" ]; then
		uci set web.mwanmodal=rule
		uci set web.mwanmodal.target='/modals/mwan-modal.lp'
		uci add_list web.mwanmodal.roles='admin' 
		uci add_list web.mwanmodal.roles='engineer'
		uci add_list web.ruleset_main.rules='mwanmodal'
	fi
	if [ ! "$(uci get -q web.fastcacheoptionmodal)" ]; then
		uci set web.fastcacheoptionmodal=rule
		uci set web.fastcacheoptionmodal.target='/modals/fast-cache-option-modal.lp'
		uci add_list web.fastcacheoptionmodal.roles='admin' 
		uci add_list web.fastcacheoptionmodal.roles='engineer'
		uci add_list web.ruleset_main.rules='fastcacheoptionmodal'
	fi
	if [ ! "$(uci get -q web.dosprotectmodal)" ]; then
		uci set web.dosprotectmodal=rule
		uci set web.dosprotectmodal.target='/modals/dosprotect-modal.lp'
		uci add_list web.dosprotectmodal.roles='admin' 
		uci add_list web.dosprotectmodal.roles='engineer'
		uci add_list web.ruleset_main.rules='dosprotectmodal'
	fi
	if [ ! "$(uci get -q web.mmpbxdectmodal)" ]; then
		uci set web.mmpbxdectmodal=rule
		uci set web.mmpbxdectmodal.target='/modals/mmpbx-dect-modal.lp'
		uci add_list web.mmpbxdectmodal.roles='admin' 
		uci add_list web.mmpbxdectmodal.roles='engineer'
		uci add_list web.ruleset_main.rules='mmpbxdectmodal'
	fi
	if [ ! "$(uci get -q web.nfcmodal)" ]; then
		uci set web.nfcmodal=rule
		uci set web.nfcmodal.target='/modals/nfc-modal.lp'
		uci add_list web.nfcmodal.roles='admin' 
		uci add_list web.nfcmodal.roles='engineer'
		uci add_list web.ruleset_main.rules='nfcmodal'
	fi
	if [ ! "$(uci get -q web.stats)" ]; then
		uci set web.stats=rule
		uci set web.stats.target='/stats.lp'
		uci add_list web.stats.roles='admin' 
		uci add_list web.stats.roles='engineer'
		uci add_list web.ruleset_main.rules='stats'
	fi
	if [ ! "$(uci get -q web.cards)" ]; then
		uci set web.cards=rule
		uci set web.cards.target='/cards.lp'
		uci add_list web.cards.roles='admin' 
		uci add_list web.cards.roles='engineer'
		uci add_list web.ruleset_main.rules='cards'
	fi
	if [ ! "$(uci get -q web.ajaxinfotrafficcard)" ]; then
		uci set web.ajaxinfotrafficcard=rule
		uci set web.ajaxinfotrafficcard.target='/ajax/traffic_graph.lua'
		uci add_list web.ajaxinfotrafficcard.roles='admin' 
		uci add_list web.ajaxinfotrafficcard.roles='engineer'
		uci add_list web.ruleset_main.rules='ajaxinfotrafficcard'
	fi
	if [ ! "$(uci get -q web.ecomodal)" ]; then
		uci set web.ecomodal=rule
		uci set web.ecomodal.target='/modals/eco-modal.lp'
		uci add_list web.ecomodal.roles='admin' 
		uci add_list web.ecomodal.roles='engineer'
		uci add_list web.ruleset_main.rules='ecomodal'
	fi
	if [ ! "$(uci get -q web.modguimodal)" ]; then
		uci set web.modguimodal=rule
		uci set web.modguimodal.target='/modals/modgui-modal.lp'
		uci add_list web.modguimodal.roles='admin' 
		uci add_list web.modguimodal.roles='engineer'
		uci add_list web.ruleset_main.rules='modguimodal'
	fi
	if [ ! "$(uci get -q web.ajaxinfoconndevicecard)" ]; then
		uci set web.ajaxinfoconndevicecard=rule
		uci set web.ajaxinfoconndevicecard.target='/ajax/connected_device.lua'
		uci add_list web.ajaxinfoconndevicecard.roles='admin' 
		uci add_list web.ajaxinfoconndevicecard.roles='engineer'
		uci add_list web.ruleset_main.rules='ajaxinfoconndevicecard'
	fi
	if [ ! "$(uci get -q web.ajaxinfoportscard)" ]; then
		uci set web.ajaxinfoportscard=rule
		uci set web.ajaxinfoportscard.target='/ajax/port_status.lua'
		uci add_list web.ajaxinfoportscard.roles='admin' 
		uci add_list web.ajaxinfoportscard.roles='engineer'
		uci add_list web.ruleset_main.rules='ajaxinfoportscard'
	fi
	if [ ! "$(uci get -q web.ajaxinfommpbxstatuscard)" ]; then
		uci set web.ajaxinfommpbxstatuscard=rule
		uci set web.ajaxinfommpbxstatuscard.target='/ajax/mmpbx_status.lua'
		uci add_list web.ajaxinfommpbxstatuscard.roles='admin' 
		uci add_list web.ajaxinfommpbxstatuscard.roles='engineer'
		uci add_list web.ruleset_main.rules='ajaxinfommpbxstatuscard'
	fi
	if [ ! "$(uci get -q web.error)" ]; then
		uci set web.error=rule
		uci set web.error.target='/error.lua'
		uci add_list web.error.roles='admin' 
		uci add_list web.error.roles='engineer'
		uci add_list web.ruleset_main.rules='error'
	fi
}

check_relay_dhcp() {
	#Check if dhcp relay is enabled
	if [ ! "$(uci get -q dhcp.relay)" ]; then
		uci set dhcp.relay=relay
	fi
}

suppress_excessive_logging() {
	#Lowers the log level of daemons to suppress excessive logging to /root/messages.log
	if [ "$(uci get -q igmpproxy.globals.trace)" == "1" ]; then
		uci set igmpproxy.globals.trace='0'
	fi
	/etc/init.d/mobiled restart #Restart this to actually disable it... (broken and shitt init.d)
	uci set wansensing.global.tracelevel='3' #we don't need that we are still connected to vdsl -.-
	if [ ! "$(uci get -q transformer.@main[0].log_level)" ]; then #shutup no description warn
		uci set transformer.@main[0].log_level='2'
	fi
	if [ ! "$(uci get -q system.@system[0].cronloglevel)" ] || [ "$(uci get -q system.@system[0].cronloglevel)" == '0' ]; then #resolve spamlog of trafficdata
		uci set system.@system[0].cronloglevel="5"
		/etc/init.d/cron restart
	fi
	if [ ! "$(uci get -q ledfw.syslog)" ]; then #suppress loggin of ledfw... we don't need it...
		uci set ledfw.syslog=syslog
		uci set ledfw.syslog.trace='0'
	fi
	if [ "$(uci get -q mmpbx.global.trace_level)" == "2" ]; then
		uci set mmpbx.global.trace_level='0'
	fi
}

check_aria_dir() {
	if [ -d /etc/config/aria2 ]; then #Fix generation of config
		mv /etc/config/aria2 /etc/aria2
	fi
	if [ "$(pgrep aria2)" ]; then
		killall aria2c
		aria2c --enable-rpc --rpc-listen-all=true --rpc-allow-origin-all --daemon=true --conf-path=/etc/aria2/aria2.conf
	fi
}

led_integration() {
	#Fix led issues
	if [ ! "$(uci get -q ledfw.status_led.enable)" ] ; then
		uci set ledfw.status_led=status_led
		uci set ledfw.status_led.enable='0'
	fi
	if [ ! "$(uci get -q ledfw.wifi.nsc_on)" ] ; then
		uci set ledfw.wifi=service
		uci set ledfw.wifi.nsc_on='1'
	fi

	#Restart statusledeventing if old version
	if [ -f /tmp/status-led-eventing.lua_new ]; then
		ledeventing_new_md5=$(< /tmp/status-led-eventing.md5sum awk '{ print $1 }')
		ledeventing_md5=$(md5sum /sbin/status-led-eventing.lua | awk '{ print $1 }' )
		logger_command "LedEventing new md5sum: $ledeventing_new_md5"
		logger_command "LedEventing md5sum: $ledeventing_md5"
		if [ "$ledeventing_new_md5" ] && [ "$ledeventing_new_md5" != "$ledeventing_md5" ]; then
			rm /sbin/status-led-eventing.lua
			mv /tmp/status-led-eventing.lua_new /sbin/status-led-eventing.lua
			rm /tmp/status-led-eventing.md5sum
			/usr/share/transformer/scripts/restart_leds.sh
		else
			rm /tmp/status-led-eventing.lua_new /tmp/status-led-eventing.md5sum
		fi
	fi
}

check_wansensing() {
	#Make sure that wansensing is under the correct dir
	if [ -d /usr/lib/lua/wansensing ] && [ ! -d /usr/lib/lua/wansensingfw ] ; then
		rm /usr/lib/lua/wansensing/scripthelpers.lua
		mv /usr/lib/lua/wansensingfw/scripthelpers.lua /usr/lib/lua/wansensing/scripthelpers.lua
		rm -r /usr/lib/lua/wansensing
	fi
}

remove_downgrade_bit() {
	if [ "$(uci get -q env.rip.board_mnemonic)" == "VBNT-S" ] && [ "$(uci get -q env.var.prod_number)" == "4132" ] && [ -f /proc/rip/0123 ]; then
		logger_command "Downgrade limitation bit detected... Removing..."
		rmmod keymanager
		rmmod ripdrv
		mv /lib/modules/3.4.11/ripdrv.ko /lib/modules/3.4.11/ripdrv.ko_back
		mv /root/ripdrv.ko /lib/modules/3.4.11/ripdrv.ko
		insmod ripdrv
		echo 0123 > /proc/rip/delete
		echo 0122 > /proc/rip/delete
		rmmod ripdrv
		logger_command "Restoring original driver"
		rm /lib/modules/3.4.11/ripdrv.ko
		mv /lib/modules/3.4.11/ripdrv.ko_back /lib/modules/3.4.11/ripdrv.ko
		insmod ripdrv
		insmod keymanager
	elif [ -f /root/ripdrv.ko ]; then
		rm /root/ripdrv.ko
	fi
}

apply_right_opkg_repo() {
	if [ -f /etc/opkg.conf_17.3 ]; then
		local marketing_version="$(uci get -q version.@version[0].marketing_version)"
		if [ "$marketing_version" ]; then
			if echo "$marketing_version" | grep -q "17.3" ; then
				if [ -f /etc/okpg.conf ]; then
					rm /etc/okpg.conf
				fi
				mv /etc/opkg.conf_17.3 /etc/opkg.conf
				rm /etc/opkg.conf_16.3
			else
				if [ -f /etc/okpg.conf ]; then
					rm /etc/okpg.conf
				fi
				mv /etc/opkg.conf_16.3 /etc/opkg.conf
				rm /etc/opkg.conf_17.3
			fi
		fi
	fi
}

real_ver_entitied() {
	if [ -f /rom/etc/uci-defaults/tch_5000_versioncusto ] && [ -f /etc/config/versioncusto ]; then
		local short_ver="$(< /proc/banktable/activeversion grep -Eo '.*\..*\.[0-9]*-[0-9]*' )"
		local real_ver=$(< /rom/etc/uci-defaults/tch_5000_versioncusto grep "$short_ver" | awk '{print $2}')
		uci set versioncusto.override.fwversion_override_latest="$latest_version_on_TIM_cwmp"
		if [ "$real_ver" == "" ]; then
			real_ver="Not Found"
		fi
		if [ ! "$(uci get -q versioncusto.override.fwversion_override_real)" ]; then
			uci set versioncusto.override.fwversion_override_real="$real_ver"
		elif [ "$(uci get -q versioncusto.override.fwversion_override_real)" != "$real_ver" ]; then
			uci set versioncusto.override.fwversion_override_real="$real_ver"
		fi
		if [ "$(uci get -q modgui.var.skip_version_spoof)" ]; then
			uci del modgui.var.skip_version_spoof
		fi
		#Set version to latest stable...
		if [ -f /overlay/.skip_version_spoof ]; then
			uci set modgui.var.version_spoof_mode="disabled"
			uci set versioncusto.override.fwversion_override="$real_ver"
			rm /overlay/.skip_version_spoof
		else
			if [ "$(uci get -q modgui.var.version_spoof_mode)" ]; then
				if [ "$(uci get -q modgui.var.version_spoof_mode)" == "enabled" ]; then
					uci set versioncusto.override.fwversion_override="$latest_version_on_TIM_cwmp"
				elif [ "$(uci get -q modgui.var.version_spoof_mode)" == "disabled" ]; then
					uci set versioncusto.override.fwversion_override="$real_ver"
				fi
			else
				uci set modgui.var.version_spoof_mode="enabled"
				uci set versioncusto.override.fwversion_override="$latest_version_on_TIM_cwmp"
			fi
		fi
		uci commit modgui
	fi
}

new_wol_implementation() {
	#Enable WoL
	if [ -f /lib/functions/firewall-wol.sh ]; then
		rm /lib/functions/firewall-wol.sh
		uci set wol.config.dest_port=9
		/etc/init.d/wol restart
	fi
}

add_xdsl_option() {
	if [ ! "$(uci get -q xdsl.dsl0.sra)" ]; then
		uci set xdsl.dsl0.sra=1
	fi
	if [ ! "$(uci get -q xdsl.dsl0.bitswap)" ]; then
		uci set xdsl.dsl0.bitswap=1
	fi
	if [ ! "$(uci get -q xdsl.dsl0.snr)" ]; then
		uci set xdsl.dsl0.snr=0
	fi
	# Trying to understanding why this option were not applied i found that this option was the culprit
	# So this hex code means something... i found that the first bit is related to sra (>5 activate sra)
	# The third is related to bitswap (>2) enables it
	# demod_cap2_value (default 0x390000)
	# setting them to 0x000000 disable  sesdrop (second bit <6) CoMinMgn (first bit >1) 24k (first bit 1) 
	uci set xdsl.dsl0.demod_cap_mask="0x00047a"
	uci set xdsl.dsl0.demod_cap_value="0x00047a"
}

create_simbolic_utility() {
	if [ ! -h /usr/sbin/upgradegui ]; then
		upgrade_utility=/usr/share/transformer/scripts/upgradegui
		check_ver=/usr/share/transformer/scripts/checkver
		if [ -f $upgrade_utility ]; then
			ln -s $upgrade_utility /usr/sbin/upgradegui
			ln -s $check_ver /usr/sbin/checkver
		fi
	fi
}

update_checkver_upgrade_script() {
	if [ -f /usr/share/transformer/scripts/upgradegui.sh ]; then
		rm /usr/sbin/upgradegui
		rm /usr/sbin/checkver
		create_simbolic_utility
		rm /usr/share/transformer/scripts/upgradegui.sh
		rm /usr/share/transformer/scripts/checkver.sh
	fi
}

apply_specific_DGA_package() {
	logger_command "DGA device detected!"
	logger_command "Extracting custom-ripdrv-specificDGA.tar.bz2 ..."
	if [ -f /tmp/custom-ripdrv-specificDGA.tar.bz2 ]; then
		bzcat /tmp/custom-ripdrv-specificDGA.tar.bz2 | tar -C / -xf -
	fi
	logger_command "Extracting telnet_support-specificDGA/TG800.tar.bz2 ..."
	if [ -f /tmp/telnet_support-specificDGA.tar.bz2 ]; then
		bzcat /tmp/telnet_support-specificDGA.tar.bz2 | tar -C / -xf -
	fi
	logger_command "Extracting upgrade-pack-specificDGA.tar.bz2 ..."
	if [ -f /tmp/upgrade-pack-specificDGA.tar.bz2 ]; then
		bzcat /tmp/upgrade-pack-specificDGA.tar.bz2 | tar -C / -xf -
	fi
	logger_command "Extracting upnpfix-specificDGA.tar.bz2 ..."
	if [ -f /tmp/upnpfix-specificDGA.tar.bz2 ]; then
		bzcat /tmp/upnpfix-specificDGA.tar.bz2 | tar -C / -xf -
	fi
	logger_command "Extracting dlnad_supprto-specificDGA.tar.bz2 ..."
	if [ -f /tmp/dlnad_supprto-specificDGA.tar.bz2 ]; then
		if [ ! -f /usr/bin/dlnad ]; then
			bzcat /tmp/dlnad_supprto-specificDGA.tar.bz2 | tar -C / -xf -
		fi
	fi
	logger_command "Extracting wgetfix-specificDGA.tar.bz2 ..."
	if [ -f /tmp/wgetfix-specificDGA.tar.bz2 ]; then
		if [ ! "$(opkg info wget | grep Version | grep 1.17.1)" ]; then
			bzcat /tmp/wgetfix-specificDGA.tar.bz2 | tar -C /tmp -xf -
			opkg install /tmp/wget_1.17.1-1_brcm63xx-tch.ipk
			rm /tmp/wget_1.17.1-1_brcm63xx-tch.ipk
		fi
	fi
}

apply_specific_TG800_package() {
	logger_command "Extracting telnet_support-specificDGA/TG800.tar.bz2 ..."
	if [ -f /tmp/telnet_support-specificDGA.tar.bz2 ]; then
		bzcat /tmp/telnet_support-specificDGA.tar.bz2 | tar -C / -xf -
	fi
}

apply_specific_TG789_package() {
	logger_command "Extracting telnet_support-specificTG789/tg799.tar.bz2 ..."
	if [ -f /tmp/telnet_support-specificTG789.tar.bz2 ]; then
		bzcat /tmp/telnet_support-specificTG789.tar.bz2 | tar -C / -xf -
	fi
}

apply_specific_TG799_package() {
	logger_command "Extracting telnet_support-specificTG789/tg799.tar.bz2 ..."
	if [ -f /tmp/telnet_support-specificTG789.tar.bz2 ]; then
		bzcat /tmp/telnet_support-specificTG789.tar.bz2 | tar -C / -xf -
	fi
}

clean_specific_file() {
	rm /tmp/*specific*.tar.bz2
}

fcctlsettings_daemon() {
	if [ -f /etc/config/fcctlsettings ]; then
		if [ "$(< /etc/config/fcctlsettings grep 'mcast-learn')" ]; then
			rm /etc/config/fcctlsettings #NEVER EVER WRITE - IN CONFIG FILE... 
		fi
	fi
	if [ ! -f /etc/config/fcctlsettings ]; then
		if [ -f /etc/config/fcctlsettings_new ]; then
			mv /etc/config/fcctlsettings_new /etc/config/fcctlsettings
		fi
	else
		if [ -f /etc/config/fcctlsettings_new ]; then
			rm /etc/config/fcctlsettings_new
		fi
	fi
	if [ ! -k /etc/rc.d/S99fcctlsettings ] && [ -f /etc/init.d/fcctlsettings ]; then
		chmod 755 /etc/init.d/fcctlsettings
		/etc/init.d/fcctlsettings enable
		/etc/init.d/fcctlsettings start > /dev/null
	fi
}

sfp_rework() {
	if [ "$(uci get -q network.sfp)" ]; then
		logger_command "Moving sfp to sfptag..."
		uci rename network.sfp=sfptag
		class_target=10
		if [ "$(uci get network.lan.ipaddr)" == "192.168.$class_target.1" ]; then
			class_target=$class_target+10
		fi
		uci set network.sfptag.ipaddr=192.168.$class_target.1
		touch /root/.sfp_change
	fi
}

unlock_ssh_wan_tiscali() {
	if [ "$(uci get -q firewall.wan_SSH_rule1)" ]; then
		uci del firewall.wan_SSH_rule1
	fi
	if [ "$(uci get -q firewall.wan_SSH_rule5)" ]; then
		uci del firewall.wan_SSH_rule5
	fi
}

telstra_support_check() {
	################# telstra gui support ###################
	# We add rule anyway as if not present nginx gves 404 ###
        logger_command "Checking to see if the Telstra Basic GUI is supported"
	
	if [ ! "$(uci get -q web.telstra_broadband.target)" ]; then
		uci set web.telstra_broadband=rule
		uci set web.telstra_broadband.target='/telstra-modals/broadband.lp'
		uci add_list web.telstra_broadband.roles='admin' 
		uci add_list web.telstra_broadband.roles='engineer'
		uci add_list web.ruleset_main.rules='telstra_broadband'
	fi
	if [ ! "$(uci get -q web.telstra_contentsharing_refresh)" ]; then
		uci set web.telstra_contentsharing_refresh=rule
		uci set web.telstra_contentsharing_refresh.target='/telstra-modals/contentsharing.lp'
		uci add_list web.telstra_contentsharing_refresh.roles='admin' 
		uci add_list web.telstra_contentsharing_refresh.roles='engineer'
		uci add_list web.ruleset_main.rules='telstra_contentsharing_refresh'
	fi
	if [ ! "$(uci get -q web.telstra_device)" ]; then
		uci set web.telstra_device=rule
		uci set web.telstra_device.target='/telstra-modals/device.lp'
		uci add_list web.telstra_device.roles='admin' 
		uci add_list web.telstra_device.roles='engineer'
		uci add_list web.ruleset_main.rules='telstra_device'
	fi
	if [ ! "$(uci get -q web.telstra_dyndns)" ]; then
		uci set web.telstra_dyndns=rule
		uci set web.telstra_dyndns.target='/telstra-modals/dyndns.lp'
		uci add_list web.telstra_dyndns.roles='admin' 
		uci add_list web.telstra_dyndns.roles='engineer'
		uci add_list web.ruleset_main.rules='telstra_dyndns'
	fi
	if [ ! "$(uci get -q web.telstra_home)" ]; then
		uci set web.telstra_home=rule
		uci set web.telstra_home.target='/telstra-gui.lp'
		uci add_list web.telstra_home.roles='admin' 
		uci add_list web.telstra_home.roles='engineer'
		uci add_list web.ruleset_main.rules='telstra_home'
	fi
	if [ ! "$(uci get -q web.telstra_parental)" ]; then
		uci set web.telstra_parental=rule
		uci set web.telstra_parental.target='/telstra-modals/parental-modal.lp'
		uci add_list web.telstra_parental.roles='admin' 
		uci add_list web.telstra_parental.roles='engineer'
		uci add_list web.ruleset_main.rules='telstra_parental'
	fi
	if [ ! "$(uci get -q web.telstra_portforwarding)" ]; then
		uci set web.telstra_portforwarding=rule
		uci set web.telstra_portforwarding.target='/telstra-modals/portforwarding.lp'
		uci add_list web.telstra_portforwarding.roles='admin' 
		uci add_list web.telstra_portforwarding.roles='engineer'
		uci add_list web.ruleset_main.rules='telstra_portforwarding'
	fi
	if [ ! "$(uci get -q web.telstra_remoteaccess)" ]; then
		uci set web.telstra_remoteaccess=rule
		uci set web.telstra_remoteaccess.target='/telstra-modals/remoteaccess.lp'
		uci add_list web.telstra_remoteaccess.roles='admin' 
		uci add_list web.telstra_remoteaccess.roles='engineer'
		uci add_list web.ruleset_main.rules='telstra_remoteaccess'
	fi
	if [ ! "$(uci get -q web.telstra_tod)" ]; then
		uci set web.telstra_tod=rule
		uci set web.telstra_tod.target='/telstra-modals/tod.lp'
		uci add_list web.telstra_tod.roles='admin' 
		uci add_list web.telstra_tod.roles='engineer'
		uci add_list web.ruleset_main.rules='telstra_tod'
	fi
	if [ ! "$(uci get -q web.telstra_traffic)" ]; then
		uci set web.telstra_traffic=rule
		uci set web.telstra_traffic.target='/telstra-modals/traffic.lp'
		uci add_list web.telstra_traffic.roles='admin' 
		uci add_list web.telstra_traffic.roles='engineer'
		uci add_list web.ruleset_main.rules='telstra_traffic'
	fi
	if [ ! "$(uci get -q web.telstra_user)" ]; then
		uci set web.telstra_user=rule
		uci set web.telstra_user.target='/telstra-modals/user.lp'
		uci add_list web.telstra_user.roles='admin' 
		uci add_list web.telstra_user.roles='engineer'
		uci add_list web.ruleset_main.rules='telstra_user'
	fi
	if [ ! "$(uci get -q web.telstra_wifi)" ]; then
		uci set web.telstra_wifi=rule
		uci set web.telstra_wifi.target='/telstra-modals/wifi.lp'
		uci add_list web.telstra_wifi.roles='admin' 
		uci add_list web.telstra_wifi.roles='engineer'
		uci add_list web.ruleset_main.rules='telstra_wifi'
	fi
	if [ ! "$(uci get -q web.telstra_wifiguest)" ]; then
		uci set web.telstra_wifiguest=rule
		uci set web.telstra_wifiguest.target='/telstra-modals/wifiguest.lp'
		uci add_list web.telstra_wifiguest.roles='admin' 
		uci add_list web.telstra_wifiguest.roles='engineer'
		uci add_list web.ruleset_main.rules='telstra_wifiguest'
	fi
	if [ ! "$(uci get -q web.telstra_helpbroadband)" ]; then
		uci set web.telstra_helpbroadband=rule
		uci set web.telstra_helpbroadband.target='/telstra-helpfiles/help_broadband.lp'
		uci add_list web.telstra_helpbroadband.roles='admin' 
		uci add_list web.telstra_helpbroadband.roles='engineer'
		uci add_list web.ruleset_main.rules='telstra_helpbroadband'
	fi
	if [ ! "$(uci get -q web.telstra_helpcontentsharing)" ]; then
		uci set web.telstra_helpcontentsharing=rule
		uci set web.telstra_helpcontentsharing.target='/telstra-helpfiles/help_contentsharing.lp'
		uci add_list web.telstra_helpcontentsharing.roles='admin' 
		uci add_list web.telstra_helpcontentsharing.roles='engineer'
		uci add_list web.ruleset_main.rules='telstra_helpcontentsharing'
	fi
	if [ ! "$(uci get -q web.telstra_helpdyndns)" ]; then
		uci set web.telstra_helpdyndns=rule
		uci set web.telstra_helpdyndns.target='/telstra-helpfiles/help_dyndns.lp'
		uci add_list web.telstra_helpdyndns.roles='admin' 
		uci add_list web.telstra_helpdyndns.roles='engineer'
		uci add_list web.ruleset_main.rules='telstra_helpdyndns'
	fi
	if [ ! "$(uci get -q web.telstra_helphome)" ]; then
		uci set web.telstra_helphome=rule
		uci set web.telstra_helphome.target='/telstra-helpfiles/help_home.lp'
		uci add_list web.telstra_helphome.roles='admin' 
		uci add_list web.telstra_helphome.roles='engineer'
		uci add_list web.ruleset_main.rules='telstra_helphome'
	fi
	if [ ! "$(uci get -q web.telstra_helpportforwarding)" ]; then
		uci set web.telstra_helpportforwarding=rule
		uci set web.telstra_helpportforwarding.target='/telstra-helpfiles/help_portforwarding.lp'
		uci add_list web.telstra_helpportforwarding.roles='admin' 
		uci add_list web.telstra_helpportforwarding.roles='engineer'
		uci add_list web.ruleset_main.rules='telstra_helpportforwarding'
	fi
	if [ ! "$(uci get -q web.telstra_helpremoteaccess)" ]; then
		uci set web.telstra_helpremoteaccess=rule
		uci set web.telstra_helpremoteaccess.target='/telstra-helpfiles/help_remoteaccess.lp'
		uci add_list web.telstra_helpremoteaccess.roles='admin' 
		uci add_list web.telstra_helpremoteaccess.roles='engineer'
		uci add_list web.ruleset_main.rules='telstra_helpremoteaccess'
	fi
	if [ ! "$(uci get -q web.telstra_helpservices)" ]; then
		uci set web.telstra_helpservices=rule
		uci set web.telstra_helpservices.target='/telstra-helpfiles/help_services.lp'
		uci add_list web.telstra_helpservices.roles='admin' 
		uci add_list web.telstra_helpservices.roles='engineer'
		uci add_list web.ruleset_main.rules='telstra_helpservices'
	fi
	if [ ! "$(uci get -q web.telstra_helptod)" ]; then
		uci set web.telstra_helptod=rule
		uci set web.telstra_helptod.target='/telstra-helpfiles/help_tod.lp'
		uci add_list web.telstra_helptod.roles='admin' 
		uci add_list web.telstra_helptod.roles='engineer'
		uci add_list web.ruleset_main.rules='telstra_helptod'
	fi
	if [ ! "$(uci get -q web.telstra_helptraffic)" ]; then
		uci set web.telstra_helptraffic=rule
		uci set web.telstra_helptraffic.target='/telstra-helpfiles/help_traffic.lp'
		uci add_list web.telstra_helptraffic.roles='admin' 
		uci add_list web.telstra_helptraffic.roles='engineer'
		uci add_list web.ruleset_main.rules='telstra_helptraffic'
	fi
	if [ ! "$(uci get -q web.telstra_helpusersetting)" ]; then
		uci set web.telstra_helpusersetting=rule
		uci set web.telstra_helpusersetting.target='/telstra-helpfiles/help_usersetting.lp'
		uci add_list web.telstra_helpusersetting.roles='admin' 
		uci add_list web.telstra_helpusersetting.roles='engineer'
		uci add_list web.ruleset_main.rules='telstra_helpusersetting'
	fi
	if [ ! "$(uci get -q web.telstra_helpwifi)" ]; then
		uci set web.telstra_helpwifi=rule
		uci set web.telstra_helpwifi.target='/telstra-helpfiles/help_wifi.lp'
		uci add_list web.telstra_helpwifi.roles='admin' 
		uci add_list web.telstra_helpwifi.roles='engineer'
		uci add_list web.ruleset_main.rules='telstra_helpwifi'
	fi

	############# end telstra gui support ################################
	if [ ! "$(uci get -q modgui.app.telstra_webui)" ]; then
		uci set modgui.app.telstra_webui="0"
	fi
	if [ -f /tmp/telstra_gui.tar.bz2 ]; then
		if [ "$(uci get -q modgui.app.telstra_webui)" == "1" ]; then
			bzcat /tmp/telstra_gui.tar.bz2 | tar -C / -xf - 
		fi
		rm /tmp/telstra_gui.tar.bz2
	fi
}

wan_sensing_clean() {
	#This will try to clean every hardcoded setting from isp config
	logger_command "Cleaning WanSensing"
	if [ -f /etc/wansensing/L2EntryExit.lua ]; then
		sed -i '/[cC][wW][mM][pP][dD]/d' /etc/wansensing/L2EntryExit.lua
		sed -i '/mtu= "1500"/{N;d}' /etc/wansensing/L2EntryExit.lua
		sed -i '/[mM][tT][uU]/d' /etc/wansensing/L2EntryExit.lua
		sed -i '/vlan = default_vlan/{N;d}' /etc/wansensing/L2EntryExit.lua
		sed -i '/vci/d' /etc/wansensing/L2EntryExit.lua
		sed -i '/vpi/d' /etc/wansensing/L2EntryExit.lua
		sed -i '/enc/d' /etc/wansensing/L2EntryExit.lua
		sed -i '/ulp/d' /etc/wansensing/L2EntryExit.lua
		sed -i '/"proto", "pppoa"/d' /etc/wansensing/L2EntryExit.lua
		sed -i '/"proto", "pppoe"/d' /etc/wansensing/L2EntryExit.lua
	fi
	if [ -f /etc/wansensing/L3EntryExit.lua ]; then
		sed -i '/delete_interface("wan")/d' /etc/wansensing/L3EntryExit.lua
		sed -i '/copy_interface/d' /etc/wansensing/L3EntryExit.lua
		sed -i '/delete("network", "ipoe"/d' /etc/wansensing/L3EntryExit.lua
	fi
	if [ -f /etc/wansensing/L3PPPEntryExit.lua ]; then
		sed -i '/delete_interface("wan")/d' /etc/wansensing/L3PPPEntryExit.lua
		sed -i '/copy_interface/d' /etc/wansensing/L3PPPEntryExit.lua
		sed -i '/"ppp"/d' /etc/wansensing/L3PPPEntryExit.lua
	fi
	if [ -f /etc/wansensing/L3DHCPSenseEntryExit.lua ]; then
		sed -i '/delete_interface("wan")/d' /etc/wansensing/L3DHCPSenseEntryExit.lua
		sed -i '/"ppp"/d' /etc/wansensing/L3DHCPSenseEntryExit.lua
		sed -i '/copy_interface/d' /etc/wansensing/L3DHCPSenseEntryExit.lua
		sed -i '/"network", "ipoe"/d' /etc/wansensing/L3DHCPSenseEntryExit.lua
		sed -i '/"wan", "auto"/d' /etc/wansensing/L3DHCPSenseEntryExit.lua
		sed -i '/"wan6", "auto"/d' /etc/wansensing/L3DHCPSenseEntryExit.lua
	fi
}

rootchecks() {

	logger_command "Setting root flag"
	uci set system.config.rooted='1' #this crate a flag in the config to know if it's rooted or not
	logger_command "Reset unlock bit"
	uci set env.var.unlockedstatus='0'
	
	encrypted_pass=$(awk -F: '/root/ {print $2 }' /etc/shadow)
	default_encrypted_pass='$5liEJpfo7NYE'
	saved_encrypted_pass=$(uci -q get modgui.var.encrypted_pass)
	
	store_pass_in_uci() {
		#Redefine encrypted_pass as this can change after the shadow check
		encrypted_pass=$(awk -F: '/root/ {print $2 }' /etc/shadow)
		echo "  New password detected!" > /dev/console
		echo "  Storing encrypted password..." > /dev/console
		uci set modgui.var.encrypted_pass="$encrypted_pass"
	}
	
	logger_command "Save root password if modified"
	if [ "$(awk -F: '/root/ {print $7 }' /etc/passwd)" != "/bin/ash" ]; then #this enable root access from login
		sed -i '1croot:x:0:0:root:/root:/bin/ash' /etc/passwd
	fi
	if [ -f /etc/shadow_old ] && [ -f /root/.reapply_due_to_upgrade ]; then
		old_encrypted_pass=$(awk -F: '/root/ {print $2 }' /etc/shadow_old)
		sed -i -e 's|"${encrypted_pass}"|"${old_encrypted_pass}"|' /etc/shadow
		rm /etc/shadow_old
		echo "  Restoring old root password as this is a firmware upgrade!" > /dev/console
	elif [ -n "$saved_encrypted_pass" ]; then
	  if [ "$encrypted_pass" != "$saved_encrypted_pass" ]; then
		if [ -f /root/.reapply_due_to_upgrade ]; then
			echo "  Setting root password from password saved in config" > /dev/console
			sed -i -e 's|"${encrypted_pass}"|"${saved_encrypted_pass}"|' /etc/shadow
		else
			echo "  Shadow contains different pass than saved one. Save it!" > /dev/console
			store_pass_in_uci
		fi
	  fi
	elif [ "$encrypted_pass" != "$default_encrypted_pass" ] ||
	  [ -f /root/.reapply_due_to_upgrade ]; then #all of this is to check the root
		echo -e "root\nroot" | passwd > /dev/null
		#Redefine encrypted_pass as this can change after the shadow check
		encrypted_pass=$(awk -F: '/root/ {print $2 }' /etc/shadow)
		if [ "$encrypted_pass" != "$default_encrypted_pass" ]; then
			sed -i -e 's|"${encrypted_pass}"|"${default_encrypted_pass}"|' /etc/shadow
		fi
		echo "  Setting root password" > /dev/console
		store_pass_in_uci
	elif [ "$encrypted_pass" == "$default_encrypted_pass" ]; then
		echo "  Root password detected" > /dev/console
	elif [ "$encrypted_pass" == "$saved_encrypted_pass" ]; then
		echo "  Changed root password detected!" > /dev/console
	fi

	if [ -z "$saved_encrypted_pass" ]; then
		store_pass_in_uci
	fi

	logger_command "Setting & Enabling Dropbear SSH Server"
	uci set dropbear.@dropbear[0].Interface='lan'
	uci set dropbear.@dropbear[0].RootLogin='1'
	uci set dropbear.@dropbear[0].RootPasswordAuth='on' #dropbear root related
	uci set dropbear.@dropbear[0].PasswordAuth='on'
	uci set dropbear.@dropbear[0].enable='1'

	uci commit dropbear
	uci commit modgui

	logger_command "Restarting Dropbear SSH Server"
	/etc/init.d/dropbear restart > /dev/null
}

ledfw_rework_TG799() {
	if [ ! "$(uci get -q button.info)" ]; then
		logger_command "Extracting ledfw_support-specificTG799.tar.bz2 and setting up status (power) button..."
		uci del button.easy_reset
		uci set button.info=button
		uci set button.info.button='BTN_3'
		uci set button.info.action='released'
		uci set button.info.handler='logger INFO button pressed ; ubus send infobutton '\''{"state":"active"}'\'''
		uci set button.info.min='0'
		uci set button.info.max='2'
		uci set ledfw.iptv.check='0'
		uci commit ledfw
	fi

	if [ -f /tmp/ledfw_support-specificTG799.tar.bz2 ]; then
		stateMachine_tar_md5=$(bzcat /tmp/ledfw_support-specificTG799.tar.bz2 | tar xf - stateMachines.md5sum -O | awk '{ print $1 }')
		stateMachine_md5=$(md5sum /etc/ledfw/stateMachines.lua | awk '{ print $1 }' )
		logger_command "StateMachine tar md5sum: $stateMachine_tar_md5"
		logger_command "StateMachine md5sum: $stateMachine_md5"
		if [ "$stateMachine_tar_md5" ] && [ "$stateMachine_tar_md5" != "$stateMachine_md5" ]; then
			logger_command "Extracting ledfw_support-specificTG799.bz2 ..."
			/usr/share/transformer/scripts/restart_leds.sh
			bzcat /tmp/ledfw_support-specificTG799.tar.bz2 | tar -C / -xf - etc/ledfw/stateMachines.lua
		fi
	fi
}

ledfw_rework_TG800() {
	if [ ! "$(uci get -q button.info)" ]; then
		logger_command "Extracting ledfw_support-specificTG800.bz2 and setting up status (wifi) button..."
		uci del button.easy_reset
		uci set button.info=button
		uci set button.info.button='BTN_1'
		uci set button.info.action='released'
		uci set button.info.handler='logger INFO button pressed ; ubus send infobutton '\''{"state":"active"}'\'''
		uci set button.info.min='0'
		uci set button.info.max='2'
		uci set button.wifi_on_off_toggle.min='2'
		uci set button.wifi_on_off_toggle.max='8'
		uci set ledfw.iptv.check='0'
		uci commit ledfw
	fi

	if [ -f /tmp/ledfw_support-specificTG800.tar.bz2 ]; then
		stateMachine_tar_md5=$(bzcat /tmp/ledfw_support-specificTG800.tar.bz2 | tar xf - stateMachines.md5sum -O | awk '{ print $1 }')
		stateMachine_md5=$(md5sum /etc/ledfw/stateMachines.lua | awk '{ print $1 }' )
		logger_command "StateMachine tar md5sum: $stateMachine_tar_md5"
		logger_command "StateMachine md5sum: $stateMachine_md5"
		if [ "$stateMachine_tar_md5" ] && [ "$stateMachine_tar_md5" != "$stateMachine_md5" ]; then
			logger_command "Extracting ledfw_support-specificTG800.bz2 ..."
			/usr/share/transformer/scripts/restart_leds.sh
			bzcat /tmp/ledfw_support-specificTG800.tar.bz2 | tar -C / -xf - etc/ledfw/stateMachines.lua
		fi
	fi
}

ledfw_rework_TG789() {
	if [ -f /tmp/ledfw_support-specificTG789.tar.bz2 ]; then
		stateMachine_tar_md5=$(bzcat /tmp/ledfw_support-specificTG789.tar.bz2 | tar xf - stateMachines.md5sum -O | awk '{ print $1 }')
		stateMachine_md5=$(md5sum /etc/ledfw/stateMachines.lua | awk '{ print $1 }' )
		logger_command "StateMachine tar md5sum: $stateMachine_tar_md5"
		logger_command "StateMachine md5sum: $stateMachine_md5"
		if [ "$stateMachine_tar_md5" ] && [ "$stateMachine_tar_md5" != "$stateMachine_md5" ]; then
			logger_command "Extracting ledfw_support-specificTG789.bz2 ..."
			/usr/share/transformer/scripts/restart_leds.sh
			bzcat /tmp/ledfw_support-specificTG789.tar.bz2 | tar -C / -xf - etc/ledfw/stateMachines.lua
		fi
	fi
}

ledfw_rework_DGA() {
	if [ "$(< /usr/lib/lua/ledframework/ubus.lua grep '\--restore default function of this')" ]; then
		cp /rom/usr/lib/lua/ledframework/ubus.lua /usr/lib/lua/ledframework/
	fi
	if [ ! "$(< /usr/lib/lua/ledframework/ubus.lua grep 'cb("fwupgrade_state_" .. msg.state)')" ]; then
		sed -i 'N;/events\['\''fwupgrade'\''\] = function(msg)/a\\t\tcb("fwupgrade_state_" .. msg.state)' /usr/lib/lua/ledframework/ubus.lua
	fi

	if [ -f /tmp/ledfw_support-specificDGA.tar.bz2 ]; then
		stateMachine_tar_md5=$(bzcat /tmp/ledfw_support-specificDGA.tar.bz2 | tar xf - stateMachines.md5sum -O | awk '{ print $1 }')
		stateMachine_md5=$(md5sum /etc/ledfw/stateMachines.lua | awk '{ print $1 }' )
		logger_command "StateMachine tar md5sum: $stateMachine_tar_md5"
		logger_command "StateMachine md5sum: $stateMachine_md5"
		if [ "$stateMachine_tar_md5" ] && [ "$stateMachine_tar_md5" != "$stateMachine_md5" ]; then
			logger_command "Extracting ledfw_support-specificDGA.bz2 ..."
			/usr/share/transformer/scripts/restart_leds.sh
			bzcat /tmp/ledfw_support-specificDGA.tar.bz2 | tar -C / -xf - etc/ledfw/stateMachines.lua
		fi
	fi
}

check_gui_tmp() {
	if [ -f /tmp/GUI_dev.tar.bz2 ]; then
		logger_command "Found GUI_dev in tmp dir... Cleaning..."
		rm /tmp/GUI_dev.tar.bz2
	fi
	if [ -f /tmp/GUI.tar.bz2 ]; then
		logger_command "Found GUI in tmp dir... Cleaning..."
		rm /tmp/GUI.tar.bz2
	fi
	if [ -d /total ]; then
		rm -r /total
	fi
}

check_wan_mode() {
	if [ ! "$(uci get -q network.config.wan_mode)" ]; then
		uci set network.config="config"
		uci set network.config.wan_mode="$(uci get -q network.wan.proto)"
	fi
}

dosprotect_inizialize() {
	if [ -f /lib/modules/3.4.11/xt_hashlimit.ko ]; then
		if [ ! -f /etc/config/dosprotect ]; then
			if [ -f /etc/config/dosprotect_orig ]; then
				mv /etc/config/dosprotect_orig /etc/config/dosprotect
			fi
		fi
		if [ -f /etc/config/dosprotect_orig ]; then
			rm /etc/config/dosprotect_orig
		fi
		if [ "$(echo /etc/rc.d/S*dosprotect)" ]; then
			/etc/init.d/dosprotect enable
			/etc/init.d/dosprotect start
		fi
	fi
}

disable_intercept() {
	if [ "$(uci get -q intercept.config.enabled)" ]; then
		if [ "$(uci get -q intercept.config.enabled)" == "1" ]; then
			uci set intercept.config.enabled='0'
			uci commit intercept
			/etc/init.d/intercept restart
		fi
	fi
}

cron_christmas() {
	if [ ! -f /etc/crontabs/root ] || [ "$(< /etc/crontabs/root grep -c "christmas_tree")" -lt 1 ]; then
		echo "*/30 * 24-26 12 * /etc/christmas_tree.sh &" >> /etc/crontabs/root
	fi
}

move_env_var() {
	if [ ! -f /etc/config/modgui ]; then
		subpart="gui app var"

		gui_entities="autoupgrade randomcolor autoupgrade_hour firstpage gui_skin new_ver outdated_ver gui_version autoupgradeview gui_hash update_branch"
		app_entities="xupnp_app blacklist_app telstra_webui transmission_webui aria2_webui amule_webui luci_webui"
		var_entities="isp ppp_mgmt ppp_realm_ipv6 ppp_realm_ipv4 encrypted_pass driver_version bank_check"

		touch /etc/config/modgui

		for part in $subpart; do
			uci set modgui.$part=$part
			for value in $(eval 'echo $'"$part"_entities); do
				uci_val="$(uci get -q env.var.$value)"
				if [ -n "$uci_val" ]; then
					uci set modgui.$part.$value=$uci_val
					uci delete env.var.$value
				fi
			done
		done

		uci commit modgui
	fi
}

disable_upload_coredump_and_reboot() {
	#disable upload to tim server for coredump...
	#This is a modified build so let's not full server with false coredump.
	if [ "$(uci get -q system.@coredump[0].action)" != "ignore" ]; then
		uci set system.@coredump[0].action="ignore"
	fi
	if [ "$(uci get -q system.@coredump[0].reboot)" != "0" ]; then
		logger_command "Disable reboot after crash, this gives race condition..."
		uci set system.@coredump[0].reboot='0'
	fi
	#Clean coredump
	if [ "$(find /root -type f -name "*.core.*")" ]; then
		for coredump in /root/*.core.* ; do
			logger_command "Removing coredump $coredump from /root..."
			rm "$coredump"
		done
	fi
}

restore_nginx() {
	#This file contain settings specific for gui
	#For example
	#client_max_body_size
	if [ ! -f /etc/nginx/ui_server.conf ]; then
		#Execute defualt script to set this value
		/rom/etc/uci-defaults/tch_0080-nginx
	fi
}

check_tmp_permission() {
	#Tmp MUST be always with permission 777
	#This is ram and is used by all process to write file so everyone should be able to write here
	#Or at leat is whay ngix needs to permit a stream between gui and the sysupgrade
	#The gui has a virtual tmp dir in it and this caused the overwrite of the permission.
	#On the gui zip che tmp dir is now with 777 permission but let's make sure this is actually applied.
	#drwxrwxrwx is how ls display 777 permission
	if [ "$(ls -ld /tmp | awk '{ print $1 }')" != "drwxrwxrwx" ]; then
		chmod 777 /tmp
	fi
}

check_isp_and_cwmp() {
	if [ "$(uci -q get modgui.var.isp)" ]; then
		if [ "$(uci -q get modgui.var.isp)" == "Other" ]; then #this disable cwmpd if it's not known ISP...
			uci set cwmpd.cwmpd_config.state='0'
			if [ "$(uci get -q cwmpd.cwmpd_config.state)" = "1" ]; then
				if [ -f /var/run/cwmpd.pid ]; then
					/etc/init.d/cwmpd stop
				fi
				/etc/init.d/cwmpd disable
			fi
		elif [ "$(uci -q get modgui.var.isp)" == "Tiscali" ]; then
			uci set cwmpd.cwmpd_config.acs_url="http://webdirect.tr69.tiscali.it:8080/ftacs-basic/ACS"
			uci set cwmpd.cwmpd_config.acs_user="technicolor"
			uci set cwmpd.cwmpd_config.acs_pass="techn_tr69@"
			uci commit cwmpd
		elif [ "$(uci -q get modgui.var.isp)" == "TIM" ]; then
			logger_command "TIM ISP detected, finding CWMP server..."
			new_platform=https://regman-mon.interbusiness.it:10800/acs/
			new_platform_bck=https://regman-bck.interbusiness.it:10501/acs/
			unified_platform=https://regman-tl.interbusiness.it:10700/acs/ 
			mgmt_platform=https://regman-tl.interbusiness.it:10500/acs/
			if [ "$(curl -s -k $new_platform --max-time 5 )" ]; then
				uci set cwmpd.cwmpd_config.acs_url=$new_platform
			elif [ "$(curl -s -k $new_platform_bck --max-time 5 )" ]; then
				uci set cwmpd.cwmpd_config.acs_url=$new_platform_bck
			elif [ "$(curl -s -k $unified_platform --max-time 5 )" ]; then
				uci set cwmpd.cwmpd_config.acs_url=$unified_platform
			elif [ "$(curl -s -k $mgmt_platform --max-time 5 )" ]; then
				uci set cwmpd.cwmpd_config.acs_url=$mgmt_platform
			else
				uci set cwmpd.cwmpd_config.acs_url="None"
			fi
			logger_command "CWMP Server detected: $(uci get cwmpd.cwmpd_config.acs_url)"
			if [ "$(uci get -q cwmpd.cwmpd_config.interface)" != "wan" ]; then
				uci set cwmpd.cwmpd_config.interface='wan'
			fi
			uci commit cwmpd
			if [ "$(uci get -q cwmpd.cwmpd_config.acs_url)" == "None" ]; then
				if [ "$(pgrep "cwmpd")" ]; then
					/etc/init.d/cwmpd stop
				fi
			else
				/etc/init.d/cwmpd enable
				if [ ! "$(pgrep "cwmpd")" ]; then
					/etc/init.d/cwmpd start
				else
					/etc/init.d/cwmpd restart
				fi
			fi
		fi
		if [ "$(uci get -q modgui.var.isp)" == "TIM" ]; then #this add specific config for TIM
			add_TIM_ppp_specific
			add_telecom_stock_dns
		else
			purify_from_tim
		fi
	fi
}

check_webui_config() {
	if [ -f /etc/config/web_unlock ]; then
		if [ ! "$(uci get -q web.changelog)" ] || [ ! "$(uci get -q web.mmpbxstatisticsmodal)" ] ; then
			mv /etc/config/web /etc/config/web_back #backup of the stock web config
			mv /etc/config/web_unlock /etc/config/web #apply unlocked universal config
		else
			rm /etc/config/web_unlock
		fi
	fi
	if [ ! "$(uci get -q wireless.global.wifi_analyzer_disable)" ]; then
		 if [ "$(uci get -q wireless.global.wifi_analyzer_disable)" != "0" ]; then
			uci set wireless.global.wifi_analyzer_disable='0'
		fi
	fi
}

reapply_gui_after_reset() {
	if [ -f /root/GUI.tar.bz2 ] && [ -s /root/GUI.tar.bz2 ]; then
		logger_command "Resetting /www dir due to firmware upgrade..."
		rm -r /www
		bzcat /root/GUI.tar.bz2 | tar -C / -xf - www
	elif [ -f /root/GUI.tar.gz ]; then
		logger_command "Resetting /www dir due to firmware upgrade..."
		rm -r /www
		tar -C / -zxf /root/GUI.tar.gz www
	fi
}

start_stop_nginx() {
	while [ "$(pgrep "nginx")" ]; do
		if [ -f /var/run/nginx.pid ]; then
			kill -KILL "$(cat /var/run/nginx.pid)"
			rm /var/run/nginx.pid
		fi
		for pid in $(pgrep nginx); do 
			kill -KILL "$pid"
		done
		/etc/init.d/nginx stop 2>/dev/null
	done
	
	nginx_count=0
	while [ "$(curl 127.0.0.1 --max-time 20 -I -s | head -n 1 | cut -d$' ' -f2)" != "200" ] && [ $nginx_count -lt 5 ]; do
		if [ $nginx_count -gt 3 ]; then
			if [ -f /var/run/nginx.pid ]; then
				kill -KILL "$(cat /var/run/nginx.pid)"
				rm /var/run/nginx.pid
			fi
			for pid in $(pgrep nginx); do 
				kill -KILL "$pid"
			done
		fi
		logger_command "Restarting nginx..." ConsoleOnly
		/etc/init.d/nginx restart 2>/dev/null
		sleep 5
		nginx_count=$((nginx_count+1))
	done
}

prevent_total_brick() {
	#Enable hardware serial console to intercept bootloops
	sed -i 's/#//' /etc/inittab
}

check_low_space_device() {
	overlay_space=$(df /overlay | sed -n 2p | awk {'{print $2}'})
	if [ "$overlay_space" -lt 33000 ]; then
		logger -s -t 'Root Script' "Detected low flash space device..."
		if [ -f /root/GUI_dev.tar.bz2 ]; then
			logger -s -t 'Root Script' "Removing stable GUI and renaming dev to stable"
			if [ -f /root/GUI.tar.bz2 ]; then
				rm /root/GUI.tar.bz2
			fi
			mv /root/GUI_dev.tar.bz2 /root/GUI.tar.bz2
		fi
		if [ -f /root/GUI.tar.bz2 ]; then
			cp /root/GUI.tar.bz2 /tmp
			rm /root/GUI.tar.bz2
			convert_gui_to_light_gz "GUI"
		fi
	fi
}

root() {

	logger -s -t 'Root Script' "Rooting in progress..."

	#This moves every garbage created before 8.11.49 in env to modgui config file
	move_env_var
	
	check_tmp_permission
	
	#THIS CHECK DEVICE TYPE AND INSTALL SPECIFIC FILE
	device_type="$(uci get -q env.var.prod_friendly_name)"

	logger_command "Applying specific model fixes..."
	[ -z "${device_type##*DGA413*}" ] && apply_specific_DGA_package
	[ -z "${device_type##*TG789*}" ] && apply_specific_TG789_package
	[ -z "${device_type##*TG799*}" ] && apply_specific_TG799_package
	[ -z "${device_type##*TG800*}" ] && apply_specific_TG800_package
	[ -z "${device_type##*DGA413*}" ] && ledfw_rework_DGA
	[ -z "${device_type##*TG789*}" ] && ledfw_rework_TG789
	[ -z "${device_type##*TG799*}" ] && ledfw_rework_TG799
	[ -z "${device_type##*TG800*}" ] && ledfw_rework_TG800

	if [ -f /tmp/custom-ripdrv-specificDGA.tar.bz2 ]; then
		clean_specific_file
		logger_command "Removing fixes and resuming root process..."
	fi

	logger_command "Disable watchdog"
	/etc/init.d/watchdog-tch stop

	logger_command "Start rooting"
	if [ ! -f /root/.check_process ]; then #this check if the placeholder exist
		touch /root/.check_process #this is a placeholder to know if the process ends correctly
	fi

	if [ -f /root/.reapply_due_to_upgrade ]; then
		reapply_gui_after_reset
	fi

	logger_command "Unlocking web interface if needed"
	check_webui_config
	logger_command "Check if variant_friendly_name set"
	check_variant_friendly_name
	logger_command "Check and cleanup"
	add_ipoe #this need to stay to make the wizard work correctly
	logger_command "Remove default DNS Servers"
	remove_default_dns #tim sets his dns on to of the loopback interface
	setup_network #Fix some missing network value
	logger_command "Purify WAN"
	puryfy_wan_interface #remove gracefull restart, could give problem
	logger_command "Fix DNS bug"
	fix_dns_dhcp_bug #disable odhcpd as ipv6 is currently broken 
	[ -z "${device_type##*DGA413*}" ] && logger_command "Enable DLNAd"
	[ -z "${device_type##*DGA413*}" ] && check_new_dlnad #this enable a new dlna deamon introduced with 17.1, the old one is keep
	logger_command "Fix Sysupgrade"
	check_upgrade_shit #this if old script are present to fix sysupgrade
	logger_command "Check original config"
	orig_config_gen #this check if new config are already present
	logger_command "Restore original mapper"
	restore_original_mapper #this restore the original file autogenerated as they are specific to the build version.
	[ -z "${device_type##*DGA413*}" ] && logger_command "Transformer lib check"
	[ -z "${device_type##*DGA413*}" ] && transformer_lib_check #another cleanup
	logger_command "Remove https check"
	remove_https_check_cwmpd #cleanup
	logger_command "Check for CSS themes"
	check_uci_gui_skin #check css
	logger_command "Check if dnsmasq daemon name is as we need it for the GUI"
	check_dnsmasq_name #check dnsmasq name in uci
	logger_command "Check driver setting"
	create_driver_setting #create diver setting if not present
	logger_command "Check Dropbear config file"
	dropbear_file_check  #check dropbear config
	logger_command "Check DDNS directory"
	check_noip_file #check ddns directory in /etc
	logger_command "Check eco paramaters"
	eco_param #This disable eco param as they introduce some latency
	[ -z "${device_type##*DGA413*}" ] && logger_command "Enable new upnp"
	[ -z "${device_type##*DGA413*}" ] && enable_new_upnp #New upnp fix
	logger_command "Sync DHCP configuration for new GUI"
	update_dhcp_config #Dhcp sync
	logger_command "Create GUI type in config"
	create_gui_type #Gui Type
	logger_command "Add new web options"
	add_new_web_rule #This check new option so that we don't replace the one present
	logger_command "New DHCPRelay Option"
	check_relay_dhcp #Sync option
	logger_command "Disable trace from igmpproxy"
	suppress_excessive_logging #Suppress logging
	logger_command "Move Aria2 dir"
	check_aria_dir #Fix config function
	logger_command "Create new option for led definitions"
	led_integration #New option led
	[ -z "${device_type##*DGA413*}" ] && logger_command "Old build detected, moving wansensing file"
	[ -z "${device_type##*DGA413*}" ] && check_wansensing # Move wansensing file to old directory
	[ -z "${device_type##*DGA413*}" ] && logger_command "Checking downgrade limitation bit"
	[ -z "${device_type##*DGA413*}" ] && remove_downgrade_bit #Use custom driver to remove this... thx @Roleo
	[ -z "${device_type##*DGA413*}" ] && logger_command "Checking opkg feeds config"
	[ -z "${device_type##*DGA413*}" ] && apply_right_opkg_repo #Check opkg conf based on version
	logger_command "Creating and checking real version"
	real_ver_entitied #Support for spoofing firm
	logger_command "Implementing WoL"
	new_wol_implementation #New Wol
	logger_command "Apply new xDSL options"
	add_xdsl_option #New xdsl option
	logger_command "Creating utility symbolic link"
	create_simbolic_utility #This create symbolic link
	logger_command "Remove old update script"
	update_checkver_upgrade_script #This clean old script
	logger_command "Adding fast cache options"
	fcctlsettings_daemon #Adds fast cache options
	[ "$device_type" == "DGA4132" ] && logger_command "Reworking sfp interface in network config..."
	[ "$device_type" == "DGA4132" ] && sfp_rework #sfp to sfptag, to solve local ip problem
	[ "$device_type" == "MediaAccess TG789vac v2" ] && logger_command "Unlocking SSH for Tiscali firmware"
	[ "$device_type" == "MediaAccess TG789vac v2" ] && unlock_ssh_wan_tiscali
	logger_command "Reinstalling Telstra GUI if needed..."
	telstra_support_check #telstra support check
	logger_command "Checking if wan_mode option exists..."
	check_wan_mode # wan_mode check
	logger_command "Inizialize and start DoSprotect..."
	dosprotect_inizialize #dosprotected inizialize function
	logger_command "Checking if intercept is enabled and disabling if it is..."
	disable_intercept #Intercept check
	logger_command "Attempt to clean the wansensing script from hardcoded interfaces..."
	wan_sensing_clean #Wansensing clean utility
	logger_command "Disabling coredump reboot..."
	disable_upload_coredump_and_reboot
	logger_command "Restoring nginx additional options if needed..."
	restore_nginx
	logger_command "Enabling hardware serial console..."
	prevent_total_brick

	rootchecks #This check root availability

	if [ "$(cat /proc/banktable/booted)" == "bank_1" ] && [ ! "$(uci get -q modgui.var.bank_check)" ]; then
		#this set bank_check bit if not present ONLY IN BANK_1, bank_2 value is set based on bank_1 value
		uci set modgui.var.bank_check="1"
	fi

	logger_command "Doing various checks and generating hashes..."
	cumulative_check_gui #Handle strange installation
	check_low_space_device

	logger_command "Add checkversion to cron..."
	if [ -f /usr/share/transformer/scripts/checkver ]; then
		checkver_cron
	fi

	cron_christmas #You guess...

	if [ -f /root/.sfp_change ]; then
		rm /root/.sfp_change
		/etc/init.d/network restart
		ifup wan
	fi

	logger_command "Applying modifications"
	uci commit
	
	logger_command "Restarting dnsmasq if needed..."
	if [ $restart_dnsmasq -eq 1 ]; then
		killall dnsmasq
		/etc/init.d/dnsmasq restart
	fi

	echo "  Process done. Your modem is now rooted!" > /dev/console

	logger_command "Checking if ISP is detected..."
	check_isp_and_cwmp

	check_gui_tmp

	logger_command "Trafficmon inizialization"
	trafficmon_support #support trafficmon

	logger_command "Resetting cwmp and watchdog"
	/etc/init.d/watchdog-tch start
	
	#This should comunicate the gui that the upgrade has finished.
	rm /root/.check_process #we remove the placeholder as the process is complete
	logger_command "Process done."
	
	#Remove reapply file as the root process after upgrade has finished.
	if [ -f /root/.reapply_due_to_upgrade ]; then
		rm /root/.reapply_due_to_upgrade
	fi

	set_transformer "rpc.system.modgui.upgradegui.state" "Finished"
	
	logger_command "Restarting transformer" ConsoleOnly
	/etc/init.d/transformer restart
	#Call a random value to check start of transformer
	get_transformer "uci.env.var.oui" > /dev/null

	#This file is present only in newer build that don't suffer this strange bug
	#if [ ! -f /usr/lib/lua/tch/logger.lua ]; then
	#	#Wait this command better way to check if transformer is fully initialized
	#	transformer-cli get uci.env.var.oui > /dev/null
	#	logger_command "Restarting transformer a second time cause it's just shit..."
	#	/etc/init.d/transformer restart
	#fi
	
	logger_command "Stopping nginx" ConsoleOnly
	start_stop_nginx
}

check_bank() {
	bank_check=$(uci get -q modgui.var.bank_check)
	bootedbank=$(cat /proc/banktable/booted)
	activebank=$(cat /proc/banktable/active)
	env_config_bank1="/overlay/bank_1/etc/config/env"
	if [ "$bootedbank" != "$activebank" ]; then
		echo "  Detected corrupted active bank... Restoring..." > /dev/console
		restore_bank
	fi

	if [ "$bootedbank" == "bank_2" ]; then
		if [ -f $env_config_bank1 ]; then
			get_config_bank1=$(< $env_config_bank1 grep bank_check | awk '{print $3}' | sed "s/'//g")
			if [ -n "$get_config_bank1" ] && [ ! "$(uci -q get modgui.var.bank_check)" ]; then
				uci set modgui.var.bank_check="$get_config_bank1"
				uci commit modgui
			fi
		else
			uci set modgui.var.bank_check="1"
			uci commit modgui
		fi
		if [ "$(uci -q get modgui.var.bank_check)" == "0" ]; then
			logger_command "Firmware in Bank_2 but check_bank set to 0... Not transferring"
			echo "  Firmware in Bank_2 but check_bank set to 0... Not transferring" > /dev/console
		else
			logger_command "Firmware in Bank_2... Transferring"
			echo "  Firmware in Bank_2... Transferring" > /dev/console
			transfer_bank
		fi
	else
		echo "  Firmware in Bank_1... Not transferring..." > /dev/console
	fi
}

check_full_rootfs() {
	rootfx_percet=$(df /overlay | sed -n 2p | awk {'{print $5}'} | sed 's|%||')
	overlay_mtdblock=$(df /overlay | sed -n 2p | awk {'{print $1}'})
	bootedbank=$( cat /proc/banktable/booted )
	#Reset if rootfs more than 97% full
	if [ "$rootfx_percet" -gt 96 ]; then
		logger_command "DETECTED FULL ROOTFS... TRYING TO RESTORE..."
		echo "  DETECTED FULL ROOTFS... TRYING TO RESTORE..." > /dev/console
		for dir in /overlay/"$bootedbank"/* ; do
			if [ ! "$dir" == "/overlay/$bootedbank/etc" ]; then
				logger_command "TRYING TO SAVE ROOT BY REMOVING EVERY DIR EXCEPT /etc"
				echo "  TRYING TO SAVE ROOT BY REMOVING EVERY DIR EXCEPT /etc" > /dev/console
				rm -r -f "$dir"
			fi
		done
		#Verify if rm did actually remove the file...
		if [ -d "/overlay/$bootedbank/root" ]; then
			logger_command "CAN'T REMOVE FILES... INITIALISING FULL ROOTFS ERASE"
			echo "  CAN'T REMOVE FILES... INITIALISING FULL ROOTFS ERASE" > /dev/console
			logger_command "THIS WILL RESTORE THE MODEM TO FACTORY SETTINGS"
			echo "  THIS WILL RESTORE THE MODEM TO FACTORY SETTINGS" > /dev/console
			mtd erase -r "$overlay_mtdblock"
		fi
	fi
}

###########################################################################################
#						Init.d function												  #
###########################################################################################

rooted=0
force=0
debug=0

force() {
	force=1
	boot
}

debug() {
	debug=1
	force=1
	boot
}

install() {
	rootchecks
}

boot() {
	logo_project
	check_full_rootfs
	check_root
	check_gui_ver
	check_isp_config
	create_symlink

	#THIS CHECK DEVICE TYPE AND INSTALL SPECIFIC FILE
	device_type="$(uci get -q env.var.prod_friendly_name)"

	if [ "$device_type" == "DGA4132" ] || [ "$device_type" == "DGA4130" ]; then 
		device_type="DGA"
	fi

	[ -z "${device_type##*DGA413*}" ] && wifi_fix_24g
	if [ $rooted -ne 1 ]; then
		echo "  Root not detected! Rooting..." > /dev/console
		root
	else
		if [ -f /root/.check_process ]; then
			echo "  Root detected but process not terminated well! Rerooting..." > /dev/console
			root
		else
			if [ $force -eq 1 ]; then
				echo "  Root detected but force flag detected! Rerooting..." > /dev/console
				root
			else
				echo "  Root detected! Doing nothing." > /dev/console
			fi
		fi
	fi
	check_bank
	echo " ----------------------------------------------------- " > /dev/console
}
