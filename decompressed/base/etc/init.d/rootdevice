#!/bin/ash /etc/rc.common

#
#
#	 Custom Gui for Technicolor Modem: utility script and modified gui for the
#	 								   Technicolor Modem interface based on OpenWrt
#
#	Copyright (C) 2018  Christian Marangi <ansuelsmth@gmail.com>
#
#	This file is part of Custom Gui for Technicolor Modem.
#
#	Custom Gui for Technicolor Modem is free software: you can redistribute it and/or modify
#	it under the terms of the GNU General Public License as published by
#	the Free Software Foundation, either version 3 of the License, or
#	(at your option) any later version.
#
#	Custom Gui for Technicolor Modem is distributed in the hope that it will be useful,
#	but WITHOUT ANY WARRANTY; without even the implied warranty of
#	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#	GNU General Public License for more details.
#
#	You should have received a copy of the GNU General Public License
#	along with Custom Gui for Technicolor Modem.  If not, see <http://www.gnu.org/licenses/>.
#
#

START=94
EXTRA_COMMANDS="force debug"
EXTRA_HELP="\
        force   Force install GUI even if looks already installed
        debug   Force install GUI with also debug logs
"
#Gui version is now autocompleted base on latest dev, this variable will be replaced by the automatic script
version_gui=TO_AUTO_COMPLETE
#Latest version on TIM cwmp for version spoof
latest_version_on_TIM_cwmp="2.2.0"

logo_project() {
  cat <<EOF >/dev/console

 █████╗ ███╗   ██╗███████╗██╗   ██╗███████╗██╗
██╔══██╗████╗  ██║██╔════╝██║   ██║██╔════╝██║
███████║██╔██╗ ██║███████╗██║   ██║█████╗  ██║
██╔══██║██║╚██╗██║╚════██║██║   ██║██╔══╝  ██║
██║  ██║██║ ╚████║███████║╚██████╔╝███████╗███████╗
╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝ ╚═════╝ ╚══════╝╚══════╝
(Modified Gui RootScript)                  (Christo)

EOF

  logger <<EOF
                                    _
    /\  (Modified Gui RootScript)  | |
   /  \    _ __   ___  _   _   ___ | |
  / /\ \  | '_ \ / __|| | | | / _ \| |
 / ____ \ | | | |\__ \| |_| ||  __/| |
/_/    \_\|_| |_||___/ \__,_| \___||_|
                            (Christo)
EOF
}

####################LOG FUNCTION#################
logger_command() {
  if [ "$debug" -eq 1 ]; then
    logger -t "Root Script" "$1"
	echo "Root Script" "$1"
  fi
}
#################################################

disable_upload_coredump_and_reboot() {
  #disable upload to tim server for coredump...
  #This is a modified build so let's not full server with false coredump.
  if [ "$(uci get -q system.@coredump[0].action)" != "ignore" ]; then
    uci set system.@coredump[0].action="ignore"
  fi
  if [ "$(uci get -q system.@coredump[0].reboot)" != "0" ]; then
    logger_command "Disable reboot after crash, this gives race condition..."
    uci set system.@coredump[0].reboot='0'
  fi
  #Clean coredump
  if [ "$(find /root -type f -name "*.core.*")" ]; then
    for coredump in /root/*.core.*; do
      logger_command "Removing coredump $coredump from /root..."
      rm "$coredump"
    done
  fi
}

enable_serial_console() {
  logger_command "Enabling hardware serial console..."
	#Enable hardware serial console to intercept bootloops
	#TODO: add a check to avoid writing everytime ... is this simple replace a risk?
	sed -i 's/#//' /etc/inittab
}

check_and_apply_root() {
  #TODO: check if root have access to shell with a known password (we should not replace if user setted but yes if was setted by ISP)
  #TODO: check dropbear config, and fix if needed
  #TODO: check firewall configm and fix if needed

  [ -f /etc/modgui_old ] && mv /etc/modgui_old /etc/config/modgui

  encrypted_pass=$(awk -F: '/root/ {print $2 }' /etc/shadow)
  default_encrypted_pass='$5liEJpfo7NYE'
  saved_encrypted_pass=$(uci -q get modgui.var.encrypted_pass)

  store_pass_in_uci() {
    #Redefine encrypted_pass as this can change after the shadow check
    encrypted_pass=$(awk -F: '/root/ {print $2 }' /etc/shadow)
    echo "  New password detected!" >/dev/console
    echo "  Storing encrypted password..." >/dev/console
    if [ ! -f /etc/config/modgui ]; then
      touch /etc/config/modgui
      uci set modgui.var=var
    fi
    uci set modgui.var.encrypted_pass="$encrypted_pass"
  }

  logger_command "Save root password if modified"
  if [ "$(awk -F: '/root/ {print $7 }' /etc/passwd)" != "/bin/ash" ]; then #this enable root access from login
    sed -i '1croot:x:0:0:root:/root:/bin/ash' /etc/passwd
  fi
  if [ -f /shadow_old ] && [ -f /root/.reapply_due_to_upgrade ]; then
    old_encrypted_pass=$(awk -F: '/root/ {print $2 }' /etc/shadow_old)
    sed -i -e 's|"${encrypted_pass}"|"${old_encrypted_pass}"|' /etc/shadow
    rm /shadow_old
    echo "  Restoring old root password as this is a firmware upgrade!" >/dev/console
  elif [ -n "$saved_encrypted_pass" ]; then
    if [ "$encrypted_pass" != "$saved_encrypted_pass" ]; then
      if [ -f /root/.reapply_due_to_upgrade ]; then
        echo "  Setting root password from password saved in config" >/dev/console
        sed -i -e 's|"${encrypted_pass}"|"${saved_encrypted_pass}"|' /etc/shadow
      else
        echo "  Shadow contains different pass than saved one. Save it!" >/dev/console
        store_pass_in_uci
      fi
    fi
  elif [ "$encrypted_pass" != "$default_encrypted_pass" ] ||
    [ -f /root/.reapply_due_to_upgrade ]; then #all of this is to check the root
    echo -e "root\nroot" | passwd >/dev/null
    #Redefine encrypted_pass as this can change after the shadow check
    encrypted_pass=$(awk -F: '/root/ {print $2 }' /etc/shadow)
    if [ "$encrypted_pass" != "$default_encrypted_pass" ]; then
      sed -i -e 's|"${encrypted_pass}"|"${default_encrypted_pass}"|' /etc/shadow
    fi
    echo "  Setting root password" >/dev/console
    store_pass_in_uci
  elif [ "$encrypted_pass" == "$default_encrypted_pass" ]; then
    echo "  Root password detected" >/dev/console
  elif [ "$encrypted_pass" == "$saved_encrypted_pass" ]; then
    echo "  Changed root password detected!" >/dev/console
  fi

  if [ -z "$saved_encrypted_pass" ]; then
    store_pass_in_uci
  fi

  logger_command "Setting & Enabling Dropbear SSH Server"
  dropbear_path="dropbear.@dropbear[0]"
  if [ "$(uci get -q dropbear.lan)" ]; then
    dropbear_path="dropbear.lan"
  fi
  uci set "$dropbear_path".Interface='lan'
  uci set "$dropbear_path".RootLogin='1'
  uci set "$dropbear_path".RootPasswordAuth='on' #dropbear root related
  uci set "$dropbear_path".PasswordAuth='on'
  uci set "$dropbear_path".enable='1'

  uci commit dropbear
  uci commit modgui

  logger_command "Restarting Dropbear SSH Server"
  /etc/init.d/dropbear restart >/dev/null
}

install_gui() {

  [[ -z "$log_progress" ]] && log_progress=0
  [[ -z "$restart_dnsmasq" ]] && restart_dnsmasq=0

  logger -s -t 'Root Script' "Installing in progress..."

  logger_command "Start rooting"
  if [ ! -f /root/.install_gui ]; then #this check if the placeholder exist
    touch /root/.install_gui #this is a placeholder to know if the install process ends correctly (removed by 99_postreq.sh)
  fi

  root #This check root availability

  if [ -d /etc/modgui_scripts ]; then
    for file in /etc/modgui_scripts/*; do
      logger_command "Executing $file" ConsoleOnly
      . $file
    done
  fi

  #Remove reapply file as the root process after upgrade has finished.
  if [ -f /root/.reapply_due_to_upgrade ]; then
    rm /root/.reapply_due_to_upgrade
  fi

  echo "  Process done. Your modem is now rooted!" >/dev/console
}

is_dual_bank()
{
  grep -c "\"bank_2\"" /proc/mtd >/dev/null
}

check_and_apply_obp() {
  check_obp=$(uci get -q modgui.var.check_obp)
  bootedbank=$(cat /proc/banktable/booted)
  activebank=$(cat /proc/banktable/active)
  notbooted=$(cat /proc/banktable/notbooted)
  notbooted_modgui_configfile="/overlay/$notbooted/etc/config/modgui"

  if [[ "$bootedbank" != "$activebank" && "$bootedbank" == "bank_2" ]]; then
    #TODO: add checks to be sure the bank_1 is unbootable (is this really needed?)
    #TODO: add checks to be sure the bank_1 overlay is SAFE and bootable (empty/prerooted?)
    echo "  OBP sanity check succeeded continue boot complete..." >/dev/console
  else
    #OBP not OK, check if was an user choice otherwise automatically apply (this should be the case called also on first install)

    if [ ! "$(uci -q get modgui.var.check_obp)" ]; then
      #we must inizialize the check_obp var as is not found
      if [ -f $notbooted_modgui_configfile ]; then
        #if we are in a clean bank_2 overlay but in the notbooted bank overlay there was a modgui config file restore var from it
        get_config_notbooted=$(< $notbooted_modgui_configfile grep check_obp | awk '{print $3}' | sed "s/'//g")
        if [ -n "$get_config_notbooted" ] && [ ! "$(uci -q get modgui.var.check_obp)" ]; then
          uci set modgui.var.check_obp="$get_config_notbooted"
          uci commit modgui
        fi
      else
        #inizialize check_obp default value and only if cannot read the var from elsewhere (inactive bank config)
        uci set modgui.var.check_obp="1"
        uci commit modgui
      fi
    fi

    if [ "$(uci -q get modgui.var.check_obp)" == "0" ]; then
      logger_command "OBP sanity check FAILED but check_obp set to 0... Not acting"
      echo "  OBP sanity check FAILED but check_obp set to 0... Not acting" >/dev/console
    else
      logger_command "OBP sanity check FAILED start autoplanning..."
      echo "  OBP sanity check FAILED start autoplanning..." >/dev/console

      if [ "$bootedbank" == "bank_2" ]; then
        # Activate bank_1
        echo bank_1 > /proc/banktable/active
        # Erase firmware in bank_1
        mtd erase bank_1
      else
        # clone bank_1 into bank_2
        mtd write bank_1 bank_2
        md5_bank_1=$(md5sum "/dev/mtd3" | awk '{ print $1 }')
        md5_bank_2=$(md5sum "/dev/mtd4" | awk '{ print $1 }')
        if [ "$md5_bank_1" == "$md5_bank_2" ]; then
          # Clean any existing overlay for bank_2 firmware
          rm -rf /overlay/bank_2
          # Make a temp copy of overlay for bank_1 firmware
          cp -rf /overlay/bank_1 /tmp/bank_overlay_backup
          # Free up overlay space by removing existing overlay for bank_1 firmware
          rm -rf /overlay/bank_1
          # Use the previously made temp copy as overlay for bank_2 firmware
          cp -rf /tmp/bank_overlay_backup /overlay/bank_2
          # Activate bank_1
          echo bank_1 > /proc/banktable/active
          # Erase firmware in bank_1
          mtd erase bank_1
        fi
        #this reboot will be called also if md5sum failed and OBP basically failed
        # Reboot to first valid firmware
        reboot
        exit 0
      fi
    fi
  fi
}

check_full_overlay() {
  overlay_percent=$(df /overlay | sed -n 2p | awk {'{print $5}'} | sed 's|%||')
  overlay_mtdblock=$(df /overlay | sed -n 2p | awk {'{print $1}'})
  bootedbank=$(cat /proc/banktable/booted)
  #Reset if rootfs more than 97% full
  if [ "$overlay_percent" -gt 96 ]; then
    logger_command "DETECTED FULL ROOTFS... TRYING TO RESTORE..."
    echo "  DETECTED FULL ROOTFS... TRYING TO RESTORE..." >/dev/console
    for dir in /overlay/"$bootedbank"/*; do
      if [ ! "$dir" == "/overlay/$bootedbank/etc" ]; then
        logger_command "TRYING TO SAVE ROOT BY REMOVING EVERY DIR EXCEPT /etc"
        echo "  TRYING TO SAVE ROOT BY REMOVING EVERY DIR EXCEPT /etc" >/dev/console
        rm -rf "$dir"
      fi
    done
    #Verify if rm did actually remove the files/folders (using /root as check) if not ERASE...
    if [ -d "/overlay/$bootedbank/root" ]; then
      logger_command "CAN'T REMOVE FILES... INITIALISING FULL ROOTFS ERASE"
      echo "  CAN'T REMOVE FILES... INITIALISING FULL ROOTFS ERASE" >/dev/console
      logger_command "THIS WILL RESTORE THE MODEM TO FACTORY SETTINGS"
      echo "  THIS WILL RESTORE THE MODEM TO FACTORY SETTINGS" >/dev/console
      mtd erase -r "$overlay_mtdblock"
    fi
  fi
}

###########################################################################################
#						Init.d function												  #
###########################################################################################

force() {
  force=1
  boot
}

debug() {
  export debug=1
  force=1
  boot
}

boot() {
  ubus send fwupgrade '{"state":"upgrading"}'

  logo_project
  check_full_overlay
  enable_serial_console
  check_and_apply_root
  disable_upload_coredump_and_reboot

  [ -z "$rooted" ] && rooted=0
  [ -z "$force" ] && force=0
  [ -z "$debug" ] && export debug=0

  if [ -f /root/.install_gui ]; then
    echo "  detected install GUI request! Installing..." >/dev/console
    install_gui
  else
    if [ $force -eq 1 ]; then
      echo "  force flag detected! Reinstalling..." >/dev/console
      install_gui
    else
      echo "  No force flag detected! Doing nothing." >/dev/console
    fi
  fi

  is_dual_bank && check_and_apply_obp

  ubus send fwupgrade '{ "state": "done" }'
}
