local lfs = require("lfs")
local gsub, sub, match, len, find = string.gsub, string.sub, string.match, string.len, string.find

if lfs.attributes("/etc/config/mmpbx", "mode") ~= "file" then
  return
end

local Multi_Services_VoiceService_i_VoiceProfile_i_ = {
    objectType = {
        name = "#ROOT",
        access = "readWrite",
        minEntries = 0,
        maxEntries = math.huge,
        numEntriesParameter = "VoiceProfileNumberOfEntries",
        enableParameter = "Enable",
        parameters = {
            Enable = {
                access = "readWrite",
                type = "string",
                enumeration = {
                    "Disabled",
                    "Quiescent",
                    "Enabled",
                },
                default = "Disabled",
            },
            Reset = {
                access = "readWrite",
                type = "boolean",
                default = "false",
            },
            --      -- NumberOfLines
            --      -- automatically created when Multi.Services.VoiceService.{i}.VoiceProfile.{i}.Line.{i}. is loaded
            Name = {
                access = "readWrite",
                type = "string",
                max = "64",
                default = "",
            },
            SignalingProtocol = {
                access = "readWrite",
                type = "string",
                enumeration = {
                    "SIP",
                    "MGCP",
                    "H323",
                },
                default = "",
            },
            MaxSessions = {
                access = "readWrite",
                type = "unsignedInt",
                default = "0",
            },
            DTMFMethod = {
                access = "readWrite",
                type = "string",
                max = "64",
                enumeration = {
                     "InBand",
                     "RFC2833",
                     "SIPInfo",
                },
                default = "InBand",
            },
            DTMFMethodG711 = {
                access = "readWrite",
                type = "string",
                max = "64",
                enumeration = {
                    "InBand",
                    "RFC2833",
                    "SIPInfo",
                },
                default = "",
            },
            Region = {
                access = "readWrite",
                type = "string",
            },
            DigitMap = {
                access = "readWrite",
                type = "string",
                max = "256",
                default = "",
            },
            DigitMapEnable = {
                access = "readWrite",
                type = "boolean",
                default = "true",
            },
            --      STUNEnable = {
            --        access = "readWrite",
            --        type = "boolean",
            --        default = "false",
            --      },
            --      STUNServer = {
            --        access = "readWrite",
            --        type = "string",
            --        max = "256",
            --        default = "",
            --      },
            --      NonVoiceBandwidthReservedUpstream = {
            --        access = "readWrite",
            --        type = "unsignedInt",
            --        default = "0",
            --      },
            --      NonVoiceBandwidthReservedDownstream = {
            --        access = "readWrite",
            --        type = "unsignedInt",
            --        default = "0",
            --      },
            PSTNFailOver = {
                access = "readWrite",
                type = "boolean",
                default = "false",
            },
            FaxPassThrough = {
                access = "readWrite",
                type = "string",
                enumeration = {
                    "Disable",
                    "Auto",
                    "Force",
                },
                default = "Auto",
            },
            ModemPassThrough = {
                access = "readWrite",
                type = "string",
                enumeration = {
                    "Disable",
                    "Auto",
                    "Force",
                },
                default = "Auto",
            },
            X_000E50_FNN = {
                access = "readWrite",
                type = "string",
                default = "",
                description = "Choose SIP/PSTN network based on this value",
            },
            X_000E50_Interface = {
                access = "readWrite",
                type = "string",
                description = "Allows to configure the network interface to be used for voice",
                default = "",
            },
	    X_000E50_ResetCode = {
	       access = "readWrite",
	       type = "string",
               description = "Reset code to reset the sip network",
	       default = "*#101",
	    },

	    X_000E50_InterDigitTimer = {
	       access = "readWrite",
	       type = "unsignedInt",
               description = "open inter-digit timer value",
	       default = "6",
	    },

	    X_000E50_ShortInterDigitTimer = {
	       access = "readWrite",
	       type = "unsignedInt",
               description = "closed inter digit timer value",
	       default = "0",
	    },
            X_000E50_SubRegion = {
               access = "readWrite",
               type = "unsignedInt",
               description = "To specify the country specific settings for SLIC(FXS), DAA(FXO), Voice drivers, and DSP",
               range = {
                  {
                     min = "0",
                     max = "10",
                  },
               },
            },
            X_FASTWEB_TimerT_RING = {
                access = "readWrite",
                type = "unsignedInt",
                description = "Watchdog for maximum duration of ringing event when CPE is the called party",
            },
        }
    }
}

local uci_helper = mapper("ucihelper")
local common = mapper('nwcommon')
local split_key = common.split_key
local findLanWanInterfaces = common.findLanWanInterfaces
local wanconn = require("transformer.shared.wanconnection")
local conn = mapper("ubus").connect()
local calls = {}
local profile_helper = require("transformer.shared.profile_helper")
local numOfFxs, numOfDect, numOfSipdev
local regionBinding = { config = "mmpbxbrcmcountry", sectionname = "global", option = "region" }
local regionExists = uci_helper.get_from_uci(regionBinding)

local enablestatus = {
    ['0'] = "Disabled",
    ['1'] = "Enabled",
    ['Enabled'] = "1",
    ['Disabled'] = "0",
}

local dialPlanDefaultOptionsMap = {
    ['enabled'] = 1,
    ['allow'] = 1,
    ['priority'] = "low",
    ['include_eon'] = 0,
    ['apply_forced_profile'] = 0,
    ['min_length'] = 1,
    ['max_length'] = 1
}

local patternTable = {
    ['('] = "%b()",
    ['['] = "%b[]",
    ['{'] = "%b{}"
}

local countryCode = {
    ['SE'] = "sweden",
    ['DK'] = "denmark",
    ['LT'] = "etsi"
}

local binding = {}
local dialplanbinding = { config = "mmpbx", sectionname = "dial_plan_generic", option = "digit_map", default = "0" }
local transactions = {}
local faxpassthrough = setmetatable({
    inband_renegotiation = "Auto",
    t38 = "Auto",
    disabled = "Disable",
    Auto = "inband_renegotiation",
    Disable = "disabled",
}, { __index = function() return "" end })

-- Array Items:
-- 1. config file name
-- 2. specific seciton type for getting sectionnames
-- 3. parent key for filter
local configs = {
    {"mmpbxrvsipnet", "network", "SIPUA"},
    {"mmpbxrvsipdev", "server", "INTUA"},
}

local function countryTR104(val, countryType)
    if calls and type(calls) == "table" then
        for country,code in pairs(calls) do
            if countryType == "tr104" and country == val then
                return code["ISOStandard"]
            elseif countryType == "country" and code["ISOStandard"] == val then
                return country
            end
        end
    end
end

local function mapCountryAndCode(val)
    for code,country in pairs(countryCode) do
        if val == country then
            return code
        elseif val == code then
            return country
        end
    end
end

local function getCountry()
    return uci_helper.get_from_uci({ config = "mmpbx", sectionname = "global", option = "country", default = "" })
end

local function subRegion(value)
    local country = getCountry()
    local region = countryTR104(country, "tr104")
    local subregion = tonumber(value)
    if region then
        if calls and type(calls) == "table" then
            for i,j in pairs(calls) do
                if region == j["ISOStandard"] and subregion == j["subRegion"] then
                    return i
                end
            end
        end
    end
    return ""
end

local function findPatternLength(pattern)
    local pcount = 0
    local pcount2 = 0
    local pcount3 = 0
    local j = 1
    local k = 1
    local i = 0
    local subpattern = pattern:gsub("%b{}", "")    -- remove quantifiers
    local subpattern1 = subpattern:gsub("%b()", "")
    local subpattern2 = subpattern1:gsub("%b[]", "")
    if subpattern1 then
        for i = 1, len(subpattern1) do
            if sub(subpattern1, i, i) == "[" then
                pcount = pcount + 1
            end
        end
        for i = 1, len(subpattern1) do
            if sub(subpattern1 , i, i)  == "|" then
                if pcount2 < (i - j) then
                    pcount2 = i - j
                end
                j = i+1
            end
        end
    end
    if subpattern then
        for i = 1, len(subpattern) do
            if sub(subpattern , i, i ) == "(" then
                local subpattern3 = ""
                for k = i + 1, len(subpattern) do
                    if sub(subpattern, k, k) == ")" then
                        break
                    else
                        subpattern3 = subpattern3 .. sub(subpattern, k, k)   -- get sub-pattern inside ()
                    end
                end
                if subpattern3 ~= "" then
                    i = k + 1
                    pcount3 = findPatternLength(subpattern3) - len(subpattern3)
                end
            end
        end
    end
    return (subpattern2 and len(subpattern2) or 0) + pcount + pcount2 + pcount3
end

local set_binding = { config = "mmpbx" }

-- The addPatternToUci function creates a new dial plan entry section for the input pattern, writes the pattern & related options to uci
local function addPatternToUci(pattern, dialPlanName, index)
    if not pattern or pattern == "" then
        return
    end
    if dialPlanName == "dial_plan_generic" then
        set_binding.sectionname = "dial_plan_entry_generic_" .. index
    else
        set_binding.sectionname = "dial_plan_entry_" .. index
    end
    set_binding.option = nil
    uci_helper.set_on_uci(set_binding, "dial_plan_entry", commitapply)
    set_binding.option = "dial_plan"
    uci_helper.set_on_uci(set_binding, dialPlanName, commitapply)

    local pattern1 = pattern:gsub(".T","")        -- remove .T; pattern1 will be used to calculate length
    set_binding.option = "pattern"
    uci_helper.set_on_uci(set_binding, "^" .. pattern1, commitapply)

    set_binding.option = "index"
    uci_helper.set_on_uci(set_binding, index, commitapply)

    -- add the default options for the dial plan entry
    for key, val in pairs(dialPlanDefaultOptionsMap) do
        set_binding.option = key
        uci_helper.set_on_uci(set_binding, val, commitapply)
    end

    --- overwirte default min & max lengths with actual values from pattern
    local min_len = findPatternLength(pattern1)
    set_binding.option = "min_length"
    uci_helper.set_on_uci(set_binding, min_len, commitapply)

    set_binding.option = "max_length"
    if pattern:match(".*()T") then
        uci_helper.set_on_uci(set_binding, min_len + 10, commitapply)
    else
        uci_helper.set_on_uci(set_binding, min_len, commitapply)
    end
    transactions[set_binding.config] = true
end

-- The parseSetPattern parses the input digitmap string (| de-limited) and identifies individual patterns.
-- when each pattern identified, the remaining part of the digitmap string is parsed further
local function parseSetPattern(dmstring, dialPlanName)
    if not dmstring or dmstring == "" then
        return
    end
    local pcount = 0  -- index to track identified patterns
    local endIndex = 1       -- index to track end of brackets
    local startIndex = 0
    local dmIndex = 1       -- to track completion of dmstring parsing
    local index = 1       -- index to parse each subpattern
    local subpattern = ""
    local remainingStr = ""
    local parsestring = dmstring
    local ch = ""
    while parsestring and dmIndex < #dmstring do
        while index and index < #parsestring do
            subpattern = ""
            remainingStr = ""
            dmIndex = dmIndex + 1

            -- check for any brackets & if found update the current index to end of the closing bracket
            ch = sub(parsestring, index, index)
	    if patternTable[ch] then
                startIndex, endIndex = parsestring:find(patternTable[ch])
                if not endIndex then
                    return nil, "Invalid digitmap string"
                end
                index = index + endIndex
            end

            -- parse till the delimiter "|" to find the pattern
            if sub(parsestring, index, index) == "|" then
               subpattern = sub(parsestring, 1, index - 1)
               remainingStr = sub(parsestring, index + 1, #parsestring)
               pcount = pcount + 1
               addPatternToUci(subpattern, dialPlanName, pcount)
               parsestring = remainingStr
               index = 1
               break
            end
            index = index + 1
            if index >= #parsestring then
                pcount = pcount + 1
                addPatternToUci(parsestring, dialPlanName, pcount)
                dmIndex = #dmstring
                break
            end
        end
    end
    return
end

local function getDigitMap()
    local resPrioHigh = ""
    local resPrioLow = ""
    local planName = ""
    local binding = { config = "mmpbx" , sectionname = "dial_plan"}

    -- get the dial plan name for which sip_net is configured
    uci_helper.foreach_on_uci(binding,function(s)
        local network = s.network
        if network and type(network) == "table" then
            for _,v in pairs(network) do
                if v == "sip_net" then
                    planName = s[".name"]
                end
            end
        end
    end)

    binding.sectionname = "dial_plan_entry"
    uci_helper.foreach_on_uci(binding,function(s)
        if s.dial_plan and s.dial_plan == planName and s.enabled and s.enabled == "1" and s.allow and s.allow == "1" then
            local pattern = s.pattern and gsub(s.pattern, "%^", "") or ""
            local length = findPatternLength(pattern)
            local digitHolder = ""
            local min_length = s.min_length and tonumber(s.min_length) or 0
            local max_length = s.max_length and tonumber(s.max_length) or 0
            if length < min_length then
                for i = length + 1 , min_length do
                    digitHolder = digitHolder .. "x"
                end
                pattern = pattern .. digitHolder
            end
            if min_length < max_length then
                pattern = pattern .. ".T"
            end
            if s.priority and s.priority == "high" then
                resPrioHigh  =  resPrioHigh ~= "" and string.format(resPrioHigh .. "|" .. pattern) or pattern
            else
                resPrioLow = resPrioLow ~= "" and string.format(resPrioLow .. "|" .. pattern) or pattern
            end
        end
    end)
    return resPrioHigh ~= "" and resPrioHigh .. "|" .. resPrioLow or resPrioLow
end

local function setDigitMap(paramname, paramvalue)
    local resPrioHigh = ""
    local resPrioLow = ""
    local planName = ""
    local binding = { config = "mmpbx" , sectionname = "dial_plan"}
    local del_binding = { config = "mmpbx" }

    -- get the dial plan name for which sip_net is configured
    uci_helper.foreach_on_uci(binding,function(s)
        local network = s.network
        if type(network) == "table" then
            for _, v in ipairs(network) do
                if v == "sip_net" then
                    planName = s[".name"]
                end
            end
        end
    end)

    -- remove all the existing dial plan entries for the above dial plan (with sip_net network)
    binding.sectionname = "dial_plan_entry"
    uci_helper.foreach_on_uci(binding,function(s)
        if s.dial_plan == planName then
	    del_binding.sectionname = s[".name"]
            del_binding.option = nil
            uci_helper.delete_on_uci(del_binding, commitapply)
            transactions[del_binding.config] = true
        end
    end)
    -- parse the digitMap string, get unique patterns and create new list of dial plan entries
    return parseSetPattern(paramvalue, planName)
end

local dtmf_setmap = setmetatable({
  RFC2833 = "rfc2833",
  SIPInfo = "sipinfo",
  InBand = "disabled",
}, { __index = function() return "" end })

local dtmf_getmap = setmetatable({
  auto = "RFC2833",
  rfc2833 = "RFC2833",
  sipinfo = "SIPInfo",
  disabled = "InBand",
}, { __index = function() return "" end })

Multi_Services_VoiceService_i_VoiceProfile_i_.entries = function(mapping, parentkey)
    local entries = {}
    if mapping.objectType.name:match("^rpc.") then
        entries = { "1" }
    else
        calls = conn:call("mmbrcm.countries", "get", {}) or {}
        for _,v in pairs(configs) do
            if v[3] == parentkey then
                binding.config = v[1]
                binding.sectionname = v[2]
                uci_helper.foreach_on_uci(binding, function(s)
                    entries[#entries + 1] = v[1] .. "|" .. s['.name']
                end)
            end
        end
    end

    numOfFxs, numOfDect, numOfSipdev = profile_helper.find_device_support(parentkey)

    return entries
end

Multi_Services_VoiceService_i_VoiceProfile_i_.get = {
    Enable = function ()
        binding.config = "mmpbx"
        binding.sectionname = "global"
        binding.option = "enabled"
        local res = uci_helper.get_from_uci(binding)
        return enablestatus[res]
    end,
    Name = function(mapping, paramname, key)
        local config, sectionname = key:match("(.*)|(.*)")
        binding.config = config
        binding.sectionname = sectionname
        binding.option = "user_friendly_name"
        return uci_helper.get_from_uci(binding)
    end,
    SignalingProtocol = "SIP",
    MaxSessions = function ()
        -- Must be less than or equal to VoiceService.{i}.Capabilities.MaxSessionCount
        -- Multi.Services.VoiceService.1.Capabilities.MaxSessionCount = 4
        binding.config = "mmpbxrvsipnet"
        binding.sectionname = "sip_net"
        binding.option = "cac"
        local cac = uci_helper.get_from_uci(binding)
        cac = tonumber(cac)
        if (cac == nil or cac == 0 or cac < -1) then
            return ""
        elseif (cac == -1 or 2 * cac > 4) then
            local maxsessions = (numOfFxs * 2)
            if (numOfDect <= 1) then
                maxsessions = maxsessions + (numOfDect * 2)
            else
            -- 4 simultaneous DECT calls
                maxsessions = maxsessions + 4
            end
            maxsessions = maxsessions + (numOfSipdev * 2)
            return tostring(maxsessions)
        else
            return tostring(2 * cac)
        end
    end,
    Region = function()
        local country = getCountry()
          if #regionExists > 0 then
             local getCode = mapCountryAndCode(country)
             if getCode then
                return getCode
             else
                return ""
             end
          end
          local tr104 = countryTR104(country, "tr104")
          if tr104 then
              return tr104
          else
              return ""
          end
    end,
    DigitMap = function()
        local digitMapState = uci_helper.get_from_uci(dialplanbinding)
        if digitMapState == "1" then
            return getDigitMap()
        else
            return ""
        end
    end,
    DigitMapEnable = function()
        return uci_helper.get_from_uci(dialplanbinding)
    end,
    FaxPassThrough = function()
        local res
        binding.config = "mmpbxbrcmfxsdev"
        binding.sectionname = "global"
        binding.option = "fax_transport"
        local faxTransport = uci_helper.get_from_uci(binding)
        res = faxpassthrough[faxTransport]
        return res or ""
    end,
    ModemPassThrough = "Auto",
    PSTNFailOver = "false",
    DTMFMethod = function(mapping, paramname, key)
        binding.config = "mmpbxrvsipnet"
        binding.sectionname = "sip_net"
        binding.option = "dtmf_relay"
        return  dtmf_getmap[uci_helper.get_from_uci(binding)] or ""
    end,
    DTMFMethodG711 = function(mapping, paramname, key)
        binding.config = "mmpbxrvsipnet"
        binding.sectionname = "sip_net"
        binding.option = "dtmf_relay"
        return  dtmf_getmap[uci_helper.get_from_uci(binding)] or ""
    end,
    X_000E50_FNN = function(mapping, paramname, key)
        binding.config = "mmpbxbrcmfxonet"
        binding.sectionname = "fxo_profile"
        binding.option = "enabled"
        local fxo_profile_enabled = uci_helper.get_from_uci(binding)
        if (fxo_profile_enabled == "0") then
            binding.config = "mmpbxrvsipnet"
            binding.sectionname = "sip_profile_0"
            binding.option = "uri"
            return uci_helper.get_from_uci(binding)
        end
        return ""
    end,
    X_000E50_Interface = function(mapping, paramname, key)
        local config, sectionname = key:match("(.*)|(.*)")
        binding.config = config
        binding.sectionname = sectionname
        binding.option = "interface"
        local value =  uci_helper.get_from_uci(binding)
        if mapping.objectType.name:match('^Device%.') then
            return resolve('Device.IP.Interface.{i}.', value) or ""
        end
        local path = ""
        local lanInterfaces = findLanWanInterfaces(false)
        local isLan = false
        for _,j in pairs(lanInterfaces) do
            if (value == j) then
                isLan = true
                break
            end
        end
        if (isLan) then
            path = resolve('InternetGatewayDevice.LANDevice.{i}.LANHostConfigManagement.IPInterface.{i}.', value)
        else
            local wanport = wanconn.get_connection_key(value)
            path = resolve('InternetGatewayDevice.WANDevice.{i}.WANConnectionDevice.{i}.WANPPPConnection.{i}.', wanport) or resolve('InternetGatewayDevice.WANDevice.{i}.WANConnectionDevice.{i}.WANIPConnection.{i}.', wanport)
        end
        return path or ""
    end,
    Reset = "0",
    X_000E50_ResetCode = function (mapping, paramname, key)
       binding.config = "mmpbx"
       binding.sectionname = "scc_entry"
       local val
       uci_helper.foreach_on_uci(binding, function(s)
         if (s["service_type"] == "RESET_NETWORK") then
	    val = s["pattern"]
	 end
       end)
       return val or "*#101"
    end,
    X_000E50_InterDigitTimer = function (mapping, paramname, key)
       binding.config = "mmpbx"
       binding.sectionname = "dial_plan_generic"
       binding.option = "open_inter_digit_timer"
       return uci_helper.get_from_uci(binding)
    end,
    X_000E50_ShortInterDigitTimer = function (mapping, paramname, key)
       binding.config = "mmpbx"
       binding.sectionname = "dial_plan_generic"
       binding.option = "closed_inter_digit_timer"
       return uci_helper.get_from_uci(binding)
    end,
    X_FASTWEB_TimerT_RING = function (mapping, paramname, key)
       binding.config = "mmpbx"
       binding.sectionname = "global"
       binding.option = "no_answer_timeout"
       return uci_helper.get_from_uci(binding)
    end,
    X_000E50_SubRegion = function()
       local country = getCountry()
       if calls and type(calls) == "table" then
          for i,j in pairs(calls) do
             if i == country then
                return tostring(j["subRegion"])
             end
          end
       end
       return ""
     end
}

local function rfc2833Mode(paramvalue)
       binding.config = "mmpbx"
       binding.sectionname = "codec_filter"

       local set_binding = {}
       set_binding.config = "mmpbx"
       set_binding.sectionname = "codec_filter"

       if (paramvalue == "RFC2833") then
            uci_helper.foreach_on_uci(binding, function(s)
              if s.name == "telephone-event" then
                 set_binding.sectionname = s[".name"]
                 set_binding.option = "allow"
                 uci_helper.set_on_uci(set_binding, "1", commitapply)
                 transactions[set_binding.config] = true
              end
            end)

            set_binding.config = "mmpbxbrcmfxsdev"
            set_binding.sectionname = "fxs_dev_0"
            set_binding.option = "codec_black_list"
            local list = uci_helper.get_from_uci(set_binding)
            if (list ~= "") then
                for index, value in ipairs(list) do
                    if value == "telephone-event" then
                       table.remove(list,index)
                       index = index - 1
                    end
                 end
                 uci_helper.set_on_uci(set_binding, list)
                 transactions[set_binding.config] = true
            end

            set_binding.sectionname = "fxs_dev_1"
            set_binding.option = "codec_black_list"
            local list = uci_helper.get_from_uci(set_binding)
            if (list ~= "") then
                for index, value in ipairs(list) do
                    if value == "telephone-event" then
                       table.remove(list,index)
                       index = index - 1
                    end
                 end
                 uci_helper.set_on_uci(set_binding, list)
                 transactions[set_binding.config] = true
            end

       elseif (paramvalue == "InBand" or paramvalue == "SIPInfo" ) then
            binding.config = "mmpbx"
            binding.sectionname = "codec_filter"

            set_binding.config = "mmpbx"
            set_binding.sectionname = "codec_filter"
            uci_helper.foreach_on_uci(binding, function(s)
                if s.name == "telephone-event" then
                   set_binding.sectionname = s[".name"]
                   set_binding.option = "allow"
                   uci_helper.set_on_uci(set_binding, "0", commitapply)
                   transactions[set_binding.config] = true
                end
            end)

            local check = 0
            set_binding.config = "mmpbxbrcmfxsdev"
            set_binding.sectionname = "fxs_dev_0"
            set_binding.option = "codec_black_list"
            local list = uci_helper.get_from_uci(set_binding)
            if (list ~= "") then
                check = 0
                for index, value in ipairs(list) do
                    if value == "telephone-event" then
                       check = 1
                    end
                 end
                 if (check ~= 1) then
                    table.insert(list, 1, "telephone-event")
                    uci_helper.set_on_uci(set_binding, list)
                    transactions[set_binding.config] = true
                 end
            else
                 list = {}
                 table.insert(list, "telephone-event")
                 uci_helper.set_on_uci(set_binding, list)
                 transactions[set_binding.config] = true
            end

            set_binding.sectionname = "fxs_dev_1"
            set_binding.option = "codec_black_list"
            local list = uci_helper.get_from_uci(set_binding)
            if (list ~= "") then
                check = 0
                for index, value in ipairs(list) do
                    if value == "telephone-event" then
                       check = 1
                    end
                 end
                 if (check ~= 1) then
                    table.insert(list, 1, "telephone-event")
                    uci_helper.set_on_uci(set_binding, list)
                    transactions[set_binding.config] = true
                 end
            else
                 list = {}
                 table.insert(list, "telephone-event")
                 uci_helper.set_on_uci(set_binding, list)
                 transactions[set_binding.config] = true
            end
       end
end

Multi_Services_VoiceService_i_VoiceProfile_i_.set = {
    Enable = function (mapping, paramname, paramvalue, key)
        binding.config = "mmpbx"
        binding.sectionname = "global"
        binding.option = "enabled"
        local val = "0"
        if paramvalue == "Quiescent" then
            paramvalue = "Disabled"
        end
        val = enablestatus[paramvalue]
        if uci_helper.get_from_uci(binding) ~= val then
            uci_helper.set_on_uci(binding, val, commitapply)
            transactions[binding.config] = true
        end
    end,
    Name = function(mapping, paramname, paramvalue, key)
        local config, sectionname = key:match("(.*)|(.*)")
        binding.config = config
        binding.sectionname = sectionname
        binding.option = "user_friendly_name"
        uci_helper.set_on_uci(binding, paramvalue, commitapply)
        transactions[binding.config] = true
    end,
    SignalingProtocol = function (mapping, paramname, paramvalue, key)
        if paramvalue == "SIP" then
            return
        end
        return nil, "Only support SIP"
    end,
    MaxSessions = function (mapping, paramname, paramvalue, key)
        -- Must be less than or equal to VoiceService.{i}.Capabilities.MaxSessionCount
        -- Multi.Services.VoiceService.1.Capabilities.MaxSessionCount = 4
        paramvalue = tonumber(paramvalue)
        if (paramvalue == 2 or paramvalue == 4) then
            binding.config = "mmpbxrvsipnet"
            binding.sectionname = "sip_net"
            binding.option = "cac"
            paramvalue = paramvalue/2
            uci_helper.set_on_uci(binding, paramvalue, commitapply)
            transactions[binding.config] = true
        elseif (paramvalue > 4) then
        -- "the value must be less than or equal to VoiceService.{i}.Capabilities.MaxSessionCount"
        -- This MAY be greater than the number of lines if each line can support more than one session
            if ((numOfFxs + numOfDect + numOfSipdev) > 2) then
                binding.config = "mmpbxrvsipnet"
                binding.sectionname = "sip_net"
                binding.option = "cac"
                paramvalue = -1
                uci_helper.set_on_uci(binding, paramvalue, commitapply)
                transactions[binding.config] = true
            else
                return nil, "Less than 2 devices are configured, so the MaxSessions must be less than 5"
            end
        else
            return nil, "the value must be non-zero even number"
        end
    end,
    Region = function(mapping, paramname, paramvalue, key)
         if #regionExists > 0 then
           local region_helper = require("transformer.shared.regionhelper")
           local countryFixed = getCountry()
           local country = mapCountryAndCode(paramvalue)
           if country and countryFixed == "" then
	      region_helper.region_set(paramvalue, transactions, commitapply)
           else
              return nil, "the country code is invalid"
           end
           return true
         end
         local country = countryTR104(paramvalue, "country")
         if country then
            paramvalue = country
         else
            return nil, "the country code is invalid"
         end
         binding.config = "mmpbx"
         binding.sectionname = "global"
         binding.option = "country"
         uci_helper.set_on_uci(binding, paramvalue, commitapply)
         transactions[binding.config] = true
         return true
    end,
    DigitMap = function(mapping, paramname, paramvalue, key)
        local digitMapState = uci_helper.get_from_uci(dialplanbinding)
        if digitMapState == "1" then
            if profile_helper.validateDigitMapString(paramvalue) then
                return setDigitMap(paramname, paramvalue)
            else
                return nil, "Invalid DigitMap String"
            end
        end
        return nil, "DigitMap is not supported"
    end,
    DigitMapEnable = function(mapping, paramname, paramvalue, key)
        uci_helper.set_on_uci(dialplanbinding, paramvalue, commitapply)
        transactions[dialplanbinding.config] = true
        return true
    end,
    FaxPassThrough = function (mapping, paramname, paramvalue, key)
        if paramvalue == "Force" then
            return nil, "can not set 'Force' for FaxPassThrough"
        else
            binding.config = "mmpbxbrcmfxsdev"
            binding.sectionname = "global"
            binding.option = "fax_transport"
            uci_helper.set_on_uci(binding, faxpassthrough[paramvalue], commitapply)
            transactions[binding.config] = true
        end
    end,
    PSTNFailOver = function (mapping, paramname, paramvalue, key)
        if paramvalue ~= "false" and paramvalue ~= "0" then
            return nil, "invalid value"
        end
    end,
    ModemPassThrough  = function ()
        return true   -- Hardcoded to set only the value "Auto"
    end,
    DTMFMethodG711 = function (mapping, paramname, paramvalue, key)
        if dtmf_setmap[paramvalue] then
            binding.config = "mmpbxrvsipnet"
            binding.sectionname = "sip_net"
            binding.option = "dtmf_relay"
            uci_helper.set_on_uci(binding, dtmf_setmap[paramvalue], commitapply)
            transactions[binding.config] = true

            rfc2833Mode(paramvalue)
        else
            return nil, "invalid value"
        end
    end,
    DTMFMethod  = function (mapping, paramname, paramvalue, key)
        if dtmf_setmap[paramvalue] then
            binding.config = "mmpbxrvsipnet"
            binding.sectionname = "sip_net"
            binding.option = "dtmf_relay"
            uci_helper.set_on_uci(binding, dtmf_setmap[paramvalue], commitapply)
            transactions[binding.config] = true

            rfc2833Mode(paramvalue)
        else
            return nil, "invalid value"
        end
    end,
    X_000E50_FNN = function (mapping, paramname, paramvalue, key)
        binding.config = "mmpbxbrcmfxonet"
        binding.sectionname = "fxo_profile"
        binding.option = "enabled"
        local fxo_profile_enabled = uci_helper.get_from_uci(binding)
        if (fxo_profile_enabled == "0") then
            binding.config = "mmpbxrvsipnet"
            binding.sectionname = "sip_profile_0"
            binding.option = "uri"
            uci_helper.set_on_uci(binding, paramvalue, commitapply)
            transactions[binding.config] = true
        elseif (fxo_profile_enabled == "1") then
            return nil, "It does not implemented for PSTN mode!"
        else
            return nil, "It is not SIP or PSTN mode"
        end
    end,
    X_000E50_Interface = function(mapping, paramname, paramvalue, key)
        -- Convert path to key; this is always the UCI/UBUS interface name, like wan, lan, ...
        local intf = ""
        if string.find(paramvalue,"InternetGatewayDevice.LANDevice.-") or string.find(paramvalue, "InternetGatewayDevice.WANDevice.-") or string.find(paramvalue, "Device.IP.Interface.-")then
        local value = tokey(paramvalue,
            "InternetGatewayDevice.LANDevice.{i}.LANHostConfigManagement.IPInterface.{i}.",
            "InternetGatewayDevice.WANDevice.{i}.WANConnectionDevice.{i}.WANIPConnection.{i}.",
            "InternetGatewayDevice.WANDevice.{i}.WANConnectionDevice.{i}.WANPPPConnection.{i}.",
            "Device.IP.Interface.{i}."
        )
        if value and value:match("|") then
            -- Interface name is the first part of the WANDevice.WANConnectionDevice.WANIP/WANPPP key
            -- Interface name is the second part of the WANDevice.WANConnectionDevice.WANIP/WANPPP key for active devices
            paramvalue, intf = split_key(value)
        else
            paramvalue = value
        end
        if (not paramvalue) then
            return nil, "Invalid value"
        end
        local config, sectionname = key:match("(.*)|(.*)")
        binding.config = config
        binding.sectionname = sectionname
        binding.option = "interface"
        if paramvalue == "ACTIVE" then
          uci_helper.set_on_uci(binding, intf, commitapply)
        else
          uci_helper.set_on_uci(binding, paramvalue, commitapply)
        end
        transactions[binding.config] = true
        else
            return nil, "given is not a valid interface"
        end
    end,
    Reset = function(mapping, paramname, paramvalue, key)
        if paramvalue == "1" then
            commitapply:newset("Services.VoiceService.{i}.VoiceProfile.{i}.Reset")
        else
            return nil, "can not reset voice profile when reset value is not 1"
        end
    end,
    X_000E50_ResetCode = function (mapping, paramname, paramvalue, key)
       binding.config = "mmpbx"
       binding.sectionname = "scc_entry"

       if (not paramvalue) then
	  return nil, "Invalid value"
       end

       local success
       uci_helper.foreach_on_uci(binding, function(s)
         if (s["service_type"] == "RESET_NETWORK") then
	    binding.sectionname = s['.name']
	    uci_helper.set_on_uci(binding, paramvalue, commitapply)
	    transactions[binding.config] = true
	    success = "1"
	 end
       end)
       if success == "1" then
	  return true
       else
	  return nil, "can not set reset code to reset_network service, check if the service is provisioned"
       end
    end,
    X_000E50_InterDigitTimer = function (mapping, paramname, paramvalue, key)
       if (not paramvalue) then
	  return nil, "Invalid value"
       end

       binding.config = "mmpbx"
       binding.sectionname = "dial_plan_generic"
       binding.option = "open_inter_digit_timer"
       uci_helper.set_on_uci(binding, paramvalue, commitapply)
       transactions[binding.config] = true
    end,
    X_000E50_ShortInterDigitTimer = function (mapping, paramname, paramvalue, key)
       if (not paramvalue) then
	  return nil, "Invalid value"
       end

       binding.config = "mmpbx"
       binding.sectionname = "dial_plan_generic"
       binding.option = "closed_inter_digit_timer"
       uci_helper.get_from_uci(binding, paramvalue, commitapply)
       transactions[binding.config] = true
    end,
    X_FASTWEB_TimerT_RING = function (mapping, paramname, paramvalue, key)
       binding.config = "mmpbx"
       binding.sectionname = "global"
       binding.option = "no_answer_timeout"
       uci_helper.set_on_uci(binding, paramvalue, commitapply)
       transactions[binding.config] = true
       return true
    end,
    X_000E50_SubRegion = function(mapping, paramname, paramvalue, key)
       local subregion = subRegion(paramvalue)
       local country = getCountry()
       if subregion ~= "" then
          if subregion == country then
             return nil, "Subregion already exist"
          else
             paramvalue = subregion
          end
       else
          return nil, "the value is invalid"
       end
       binding.config = "mmpbx"
       binding.sectionname = "global"
       binding.option = "country"
       uci_helper.set_on_uci(binding, paramvalue, commitapply)
       transactions[binding.config] = true
       return true
    end,
}

Multi_Services_VoiceService_i_VoiceProfile_i_.commit = function()
    local binding = {}
    for config in pairs(transactions) do
        binding.config = config
        uci_helper.commit(binding)
    end
    transactions = {}
end

Multi_Services_VoiceService_i_VoiceProfile_i_.revert = function()
    local binding = {}
    for config in pairs(transactions) do
        binding.config = config
        uci_helper.revert(binding)
    end
    transactions = {}
end


Multi_Services_VoiceService_i_VoiceProfile_i_.add = function ()
    error ("not implemented")
end

Multi_Services_VoiceService_i_VoiceProfile_i_.delete = function ()
    error ("not implemented")
end

local duplicator = mapper("multiroot").duplicate
local duplicates = duplicator(Multi_Services_VoiceService_i_VoiceProfile_i_, "#ROOT", {"InternetGatewayDevice.Services.VoiceService.{i}.VoiceProfile.{i}.", "Device.Services.VoiceService.{i}.VoiceProfile.{i}.", "rpc.voiceprofile.{i}."})
for _, dupli in ipairs(duplicates) do
  if dupli.objectType.name:match("^rpc.voiceprofile.") then
    for param in pairs(dupli.objectType.parameters) do
      if param ~= "MaxSessions" and param ~= "DTMFMethod" then
        dupli.objectType.parameters[param] = nil
      end
    end
  end
  register(dupli)
end

local Multi_Services_VoiceService_i_VoiceProfile_i_FaxT38_ = {
    objectType = {
      name = "#ROOT.Services.VoiceService.{i}.VoiceProfile.{i}.FaxT38.",
      access = "readOnly",
      minEntries = 1,
      maxEntries = 1,
      parameters = {
        Enable = {
          access = "readWrite",
          type = "boolean",
        },
        HighSpeedRedundancy = {
          access = "readWrite",
          type = "unsignedInt",
          range = {
              {
                  min = "0",
                  max = "3",
              },
          },
        },
        LowSpeedRedundancy = {
          access = "readWrite",
          type = "unsignedInt",
          range = {
              {
                  min = "0",
                  max = "3",
              },
          },
        },
        BitRate = {
          access = "readOnly",    -- ReadWrite not supported.
          type = "unsignedInt",
        },
        TCFMethod = {
          access = "readOnly",    -- ReadWrite not supported.
          type = "string",
          enumeration = {
            "Local",
            "Network"
          },
          default = "",
        },
        HighSpeedPacketRate = {
          access = "readOnly",    -- ReadWrite not supported.
          type = "unsignedInt",
        },
      }
    }
}

local function get_T38Redundancy(mapping, param, key)
        local res
        local brcmfxsdev_binding = {config="mmpbxbrcmfxsdev", sectionname="global", option="t38_redundancy"}
        res = uci_helper.get_from_uci(brcmfxsdev_binding)
        if res ~= nil and res >= "0" and res <= "3" then
            return res
        else
            return ""
        end
end

local function set_T38Redundancy(mapping, paramname, paramvalue, key)
        local brcmfxsdev_binding = {config="mmpbxbrcmfxsdev", sectionname="global", option="t38_redundancy"}
        local t38_redundancy = uci_helper.get_from_uci(brcmfxsdev_binding)
        if paramvalue ~= nil and paramvalue >= "0" and paramvalue <= "3" and paramvalue ~= t38_redundancy then
            uci_helper.set_on_uci(brcmfxsdev_binding, paramvalue ,commitapply)
        end
end


Multi_Services_VoiceService_i_VoiceProfile_i_FaxT38_.get = {
    Enable = function (mapping, param, key)
        local res = 0
        binding.config = "mmpbxbrcmfxsdev"
        binding.sectionname = "global"
        binding.option = "fax_transport"
        res = uci_helper.get_from_uci(binding)
        if res == "t38" then
            return "1"
        else
            return "0"
        end
    end,

    HighSpeedRedundancy = get_T38Redundancy,
    LowSpeedRedundancy = get_T38Redundancy,
    BitRate = "14400",  -- Hardcoded in sdp at mmpbxbrcmfxs
    TCFMethod = "Network",
    HighSpeedPacketRate = "20", -- Hardcoded for IMAGE codec at mmbrcm
}

Multi_Services_VoiceService_i_VoiceProfile_i_FaxT38_.set = {
    Enable = function (mapping, paramname, paramvalue, key)
        binding.config = "mmpbxbrcmfxsdev"
        binding.sectionname = "global"
        binding.option = "fax_transport"
        local fax_transport = uci_helper.get_from_uci(binding)
        if paramvalue == "1" and fax_transport ~= "t38"  then
            uci_helper.set_on_uci(binding, "t38", commitapply)
            transactions[binding.config] = true
        elseif paramvalue == "0" and fax_transport == "t38"  then
            uci_helper.set_on_uci(binding, "inband_renegotiation", commitapply)
            transactions[binding.config] = true
        end
    end,

    HighSpeedRedundancy = set_T38Redundancy,
    LowSpeedRedundancy = set_T38Redundancy,
}

Multi_Services_VoiceService_i_VoiceProfile_i_FaxT38_.commit = function()
    binding.config = "mmpbxbrcmfxsdev"
    uci_helper.commit(binding)
end

Multi_Services_VoiceService_i_VoiceProfile_i_FaxT38_.revert = function()
    binding.config = "mmpbxbrcmfxsdev"
    uci_helper.revert(binding)
end

duplicates = duplicator(Multi_Services_VoiceService_i_VoiceProfile_i_FaxT38_, "#ROOT", {"InternetGatewayDevice", "Device"})
for _, dupli in ipairs(duplicates) do
  register(dupli)
end
